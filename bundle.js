/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/scripts/data.ts":
/*!*****************************!*\
  !*** ./src/scripts/data.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"lessons\": () => (/* binding */ lessons),\n/* harmony export */   \"plantsDescriptions\": () => (/* binding */ plantsDescriptions)\n/* harmony export */ });\nconst plantsDescriptions = {\n    \"Primula veris\": \"# Primula veris\\n\" + \"\\n\" + \"## ЛРС\\n\" + \"\\n\" + \"**Primulae veris radix**\\n\" + \"\\n\" + \"## Препараты\\n\" + \"\\n\" + \"*Гербион сироп от сухого кашля с первоцветом*\\n\" + \"\\n\" + \"## Другое\\n\" + \"\\n\" + \"Содержит тритерпеновые сапонины\\n\",\n    \"Hedera helix\": \"# Hedera helix\\n\" + \"\\n\" + \"## ЛРС\\n\" + \"\\n\" + \"**Hederae folium**\\n\" + \"\\n\" + \"## Препараты\\n\" + \"\\n\" + \"* *Гербион сироп от кашля с плющом*\\n\" + \"* *Гербион таблетки для рассасывания от кашля*\\n\" + \"\\n\",\n    \"Polemonium caeruleum\": \"# Polemonium coeruleum\\n\" + \"\\n\" + \"## ЛРС\\n\" + \"\\n\" + \"**Polemonii coerulei rhizoma cum rabicibus**\\n\" + \"\\n\" + \"## Препараты\\n\" + \"\\n\" + \"* ***Седанол** настойка внутрь от кашля, седативное действие*\\n\" + \"* *Сироп от кашля с синюхой и солодкой*\",\n    \"Dioscorea nipponica\": \"# Dioscorea nipponica\\n\" + \"## ЛРС\\n\" + \"**Dioscoreae nipponicae rhizoma cum radicibus**\\n\" + \"## Препараты\\n\" + \"?\\n\" + \"ПКП гиперхолестеринемия\",\n    \"Panax ginseng\": \"# Panax ginseng\\n\" + \"## ЛРС\\n\" + \"**Ginseng radix**\\n\" + \"## Препараты\\n\" + \"* настойка женьшеня\\n\" + \"* фитонсол\\n\" + \"* тримунал\\n\" + \"\\n\" + \"все общетонизирующие\",\n    \"Aesculus hippocastanum\": \"# Aesculus hippocastanum\\n\" + \"## ЛРС\\n\" + \"**Aesculi hippocastani semen**\\n\" + \"**Aesculi hippocastani folium**\\n\" + \"## Препараты\\n\" + \"* Эскузан капли внутрь\\n\" + \"* Аэсцин таблетки, гель\\n\" + \"* Веносал гель\\n\" + \"\\n\" + \"### ПКП\\n\" + \"Венозная недостаточность\\n\" + \"варикоз\",\n    \"Aralia mandshurica\": \"# Aralia manshurica\\n\" + \"## ЛРС\\n\" + \"**Araliae manshuricae radix**\\n\" + \"## Препараты\\n\" + \"Сапарал табл\\n\" + \"общетонизирующие\\n\" + \"\\n\" + \"### ПКП\\n\" + \"Астения\\n\" + \"гипотония\",\n    \"Glycyrrhiza glabra\": `**Солодка голая (Лакрица) -Glycyrrhiza glabra,**\n\n**Солодка уральская - Glycyrrhiza uralensis Fisch**\n\n**Солодки корни (лакричный корень)- Glycyrrhizae radix**\n\n**Fabaceae**\n\n**Содержит пентациклические тритерпеновые сапонины, производные олеанана**\n\nМноголетник. В РБ культивируется.\n\nЗаготовка с марта по ноябрь. Неочищенный корень получают после отделения от травы, очистки от земли и разрезания или подвяливания . Очищенный корень : очищают свежие или подвяленные корни от пробки ножами или машинным способом.\n\nЕстественная и искусственная при температуре не выше 50 ºС\n\n**Химический состав:**  Тритерпеновые сапонины: ***Глицирризин (в 50р слаще сахара,** стимулирует активность реснитчатого эпителия и усиливает секреторную функцию слизистых оболочек верхних дыхательных путей, облегчает отхаркивание. Оказывает противоязвенное и противовоспалительное действие, уменьшает агрегацию тромбоцитов.**), глицирризиновая, глицирретиновая, ураленоглюкуроновая кислоты;*** флавоноиды, полисахариды, кумарины\n\n**Действие:** отхаркивающее, иммуномоделирующее, противоязвенное, антиаллергическое, антиатеросклеротическое. \n\n**ЛС:** \n\n**Отхаркивающее, противовоспалительное,:** сироп корней солодки(-), грудной эликсир(Ферейн+), таблетки солодки, отвар из сырья(ферейн+)\n\n1. **Грудной эликсир** состоит из густого экстракта солодки и раствора аммиака концентрированного с добавлением анисового масла. Применяют в качестве отхаркивающего средства при инфекционно воспалительных заболеваниях дыхательных путей, сопровождающихся образованием трудно отделяемой мокроты (в том числе трахеит, трахеобронхит). Не применяют с противокашлевыми и глюкокортикоидами . С 3 лет.\n1. **Таблетки солодки(БАД)** стимулируют функцию коры надпочечников, повышают защитные свойства слизистой ЖКТ. Применяют при воспалительных заболеваниях органов дыхания (бронхиты, бронхоэктатическая болезнь, трахеиты, бронхиальная астма); гиперацидном гастрите, аллергических заболеваниях; коллагенозах; ранних и поздних токсикозах беременных; воспалительных заболеваниях женской половой сферы; климактерическом синдроме; \n1. **Сироп корня солодки(-)** В комплексной терапии инфекционно-воспалительных заболеваний дыхательных путей (главным образом при наличии плохо отделяемого, густого и вязкого секрета).** \n\n**Отхаркивающее и противовоспалительное, противоязвенное**\n\n1. **Сироп от кашля с синюхой и солодкой** (Ферейн +) Применяют в качестве отхаркивающего средства в комплексной терапии ***острых респираторных заболеваний** **верхних дых.путей(бронхит, трахеит**). **Седативное средство при различных нарушениях ЦНС (бессонница, психическое возбуждение).** **При хронических гастритах***\n\n**Иммуномоделирующее**\n\n1. **Фитонсол (солодка+ женьшень) белмедпрепараты+**\n1. **Тримунал (эхинация+ солодка+ женьшень) белмедпрепараты+**\n\nПоказания одинаковые – иммунодефицитные состояния, ОРВИ, астенический синдром, с 18 лет\n\n1. **Бад Шиповит** (шиповник, рябина, солодка, душица, лофант) Экзон`,\n    \"Что это?\": \"Что это?\",\n    \"Frangula alnus\": `**Крушина ольховидная(К. ломкая) –**_ **Frangula alnus** _**(** _ **Rhamnus frangula** _**)**\n\n_ **Frangulae cortex** _ **.**\n\n_ **Rhamnaceae.** _\n\nДревесный кустарник. Распространен во всей Европейской части СНГ.\n\nЗаготовка –весной от момента набухания почек до начала цветения. Ножом не срезают, т.к. содержится куски древесины и надрезы сильно узкие. Заготовка идет с растений не моложе 8 лет и не ниже 3 м.\n\nВ свежесобранной коре крушины – **франгуларозид** (антраноловый гликозид –димер), обладающий рвотными свойствами. Кору крушины применяют **после годичного хранения** (за этот период антранолы окисляются кислородом воздуха) –это сушка 1 год на открытом воздухе или процесс окисления франгуларозида ускоряют при температуре **100 ºС в течение 1 ч** (искусственная сушка).\n\n**Диагностический макроскопический признак: при соскабливании наружного слоя пробки обнаруживается слой малиново красного цвета (у остальных зеленый или бурый)**\n\n**Химический состав: Франгуларозид , глюкофрангулин , франгулин,** хризофанол, дубильные вещества, флавоноиды, следы ЭМ.\n\n**Действие** : Слабительное, противовоспалительное. Кратковременное лечение эпизодических запоров.\n\nФармакологический эффект развивается через 8 -10 часов.\n\nЛС:\n\n1. **Сырье (+Калина, Биотест, Украина )** – приготовление отваров, чая - кратковременное применение при эпизодических(!) запорах. НЕЛЬЗЯ ПРИ ХРОНИЧЕСКИХ.\n2. **Крушины сироп(-)** – при хронических запорах(!)\n3. **Викаир(-), викалин(+ Украина**) - оказывает вяжущее, антацидное, слабительное и спазмолитическое действие. Язвенная болезнь желудка и двенадцатиперстной кишки, гиперацидный гастрит (при запорах).\n4. **Алакс(+ польша)** - капский сабур, порошок+ сухой экстракт коры крушины. Предназначен для кратковременного применения при спорадически возникающих запорах.\n5. **жидкий и сухой экстракт**\n6. **желудочный сбор № 3**** (падис, Украина+)**\n7. **слабительный сбор № 1. (Украина+)** - крушина, крапива, тысячелистник.\n`,\n    \"Rhamnus cathartica\": `**Жостер слабительный (Крушина слабительная) -**_ **Rhamnus cathartica** _\n\n_ **Rhamni catharticae fructus.** _\n\n_ **Rhamnaceae.** _\n\nКустарник. Встречается в Европе, Западной Сибири, Казахстане, средней Азии и на Кавказе.\n\n**Внутри три косточки треугольно-выпуклые.**\n\nЗаготовка –в период полной зрелости (сентябрь-октябрь) вручную.\n\n**Недопустимые примеси : плоды крушины (вызывают рвоту) неблестящие шарообразные костянки с 2 чечевицеобразными косточками с клювовидным хрящеватым выростом.**\n\n**Химический состав: Глюкофрангулин, франгулин франгула эмодин, жостерин,** флавоноиды, органические кислоты, сахара, пектины.\n\n**ЛС: сырье**\n\n**Действие и применение:** Слабительное, противовоспалительное. Кратковременное лечение эпизодических запоров.`,\n    \"Cassia acutifolia\": `**Сенна остролистная –** _ **Cassia acutifolia** _\n\n**сенна узколистная** _ **Cassia angustifolia** _\n\n_ **Sennae folium cum fructus.** _\n\n_ **Sennae folium.** _\n\nСенныостролистнойплоды –_ **Sennae fructus acutifoliae.** _\n\nСенныузколистнойплоды_ **–Senna efructus angustifoliae.** _\n\n_ **Fabaceae.** _\n\nКсерофитный кустарник. Растение широко распространено в Африке. Культивируется в Индии, а также в Средней Азии (как однолетнее растение).\n\nСкашивают верхнюю часть растения (в фазу цветения и плодоношения), высушивают, обмолачивают и удаляют более толстые одревесневшие части стеблей. Проводят 3 сбора за сезон. Осенью обмолачивают семена.\n\n**Химический состав** _ **.** _ Сеннозиды А, В, глюкореин, их гликозиды флавоноиды, смолы.\n\nСмолы оказывают раздражающее действие на слизистую кишечника, вызывая колики, спастические боли живота, тошнота. Они переходят в горячую воду. Для их удаления отвар из сырья фильтруют после охлаждения, когда смола затвердевает и остается на фильтре.\n\n**Действие:** слабительное\n\n**Применение:** хронические запоры, гипо- и атония кишечника, регулирование стула при геморрое, проктите, анальных трещинах, очищение кишечника перед диагностическими и лечебными процедурами.\n\n**Лекарственные средства**. Сырье(биотест, Украина), сухой экстракт, Сенадексин(таблетки сухого экстракта, + Украина), Регулакс(кубики из измельченных плодов сенны, с 12 лет, + Германия), сенна таблетки из сухого экстракта, Турбослим экспресс (комплексное средство для похудания, очищения кишечника).\n`,\n    \"Rheum palmatum\": `**Ревень тангутский–** _ **Rheum palmatum** _\n\n_ **Rhei radix.** _\n\n_ **Polygonaceae.** _\n\nМноголетник. Родина р. тангутского—Дальний Восток, Китай. В Беларуси его культивируют.\n\nЗаготовка: осенью после сбора семян на 3-4 году. Корневища очищают от остатков стеблей, моют холодной водой, режут на крупные части (не толще 3-4 см и не длиннее 15 см).\n\n**Химический состав: Антрагликозиды, дубильные в-ва.** Реум-эмодин, хризофанол\n\n**Действие:** в больших дозах – слабительное, в малых – вяжущее.\n\n**ЛС:** сырье, порошок, косметологические средства.\n`,\n    \"Rumex confertus\": `**Щавель**** конский **** – **_** Rumex confertus**_\n\n_ **Rumicis conferti radix.** _\n\n_ **Polygonaceae.** _\n\nМноголетник. Широко распространен как сорное растение.\n\nКорни заготавливают осенью –в начале отмирания надземных частей (август-сентябрь) или весной (апрель-май). Промывают, разрезают поперек и продольно.\n\n**Химический состав** _ **.** _ Реум-эмодин, хризофанол и их гликозиды, дубильные вещества\n\n**ЛС:** Отвар.\n\n**Фармакологическое действие и применение**. **Слабительное в больших дозах, вяжущее в малых дозах, противовоспалительное,** кровоостанавливающее, ранозаживляющее. Применяют при колитах и энтероколитах, заболеваниях печени, наружно при ожогах, кожных язвах, гнойных ран и т.п.\n`,\n    \"Aloe arborescens\": `**Алоэ древовидное (Столетник) –**_ **Aloё arborescens** _\n\n**Алоэ древовидного листья свежие –** _ **Aloёs arborescentis folium recens,** _\n\n**Алоэ древовидного листья сухие –** _ **Aloёs arborescentis folium siccum,** _\n\n**Алоэ древовидного побеги боковые свежие –** _ **Aloёs arborescentis cormus lateralis reces.** _\n\n_ **Liliaceae.** _\n\nКомнатное растение. Cуккулент. Естественно произрастает в Южной Африке, на Мадагаскаре.\n\nЛистья собирают вместе с малосочным и стеблеобъемлющим влагалищем. Нельзя собирать молодые листья верхушек (оставляют 5-7 шт). Кроме листьев собирают молодые побеги-детки. Сырье не должно хранится более 24 ч. Сбор проводят 2-3 раза за сезон. Сухие листья (метод Филатова). Выдерживают в темноте при4-8 ºС 12 сут, затем сушат при 75-80 ºС.\n\n**Химический состав: алоин, алоэ-эмодин, реум-эмодин,** хрифозанол, смолы, горечи.\n\n**Действие и применение:** наружно в качестве бактерицидного, ранозаживляющего кожных покровов и слизистых. Внутрь при гастритах, запорах(слабительное)\n\nБиостимулирующее, общетонизирующее, регенерирующее, слабительное.\n\n**ЛС: Сок алоэ в составе наружных косметических средств, жидкий экстракт в форме раствора для инъекций, капсулы, соки, сиропы, линименты.**\n\n1. **Алоэ экстракт жидкий для инъекций(БЗМП?)** –регулирует обменные процессы – стимулирует обмен в-в, ускоряет регенерацию тканей, повышает общую резистентность организма, противомикробная активность. Применяют в составе комплексной терапии воспалительных заболеваниях глаз. Для лечения рубцовых изменений тканей, трофических язв. С 1 года. При снижении аппетита, лечении ряда ЖКТ заболеваний вне стадий обострения (гастрита, гастродуоденита, энтероколита, холецистита). В составе комплексной терапии бронхиальной астмы, туберкулеза, пневмонии. И тд\n2. _Алоэ сок_ усиливает желчеотделение, секрецию пищеварительных желез, обладает слабительным действием и бактерицидной активностью в отношении болезнетворных микробов\n3. _Алоэ сироп с железом_ содержит легкоусвояемое железо для образования гемоглобина и нормального кроветворения, восполняет недостаток железа в организме, связанный с плохим его усвоением в ЖКТ, кровопотерями, неполноценным питанием, повышенной потребностью в железе (период беременности, активного роста у детей и подростков).\n4. _Алоэ линимент_ ускоряет эпителизацию, увеличивает толерантность кожи к рентгеновским облучениям, оказывает обезболивающий эффект, уменьшает чувство жжения и стянутость\n5. _Алоэ таблетки,_ покрытые оболочкой, применяются как биогенный стимулятор микроорганизмов (внутрь), противовоспалительным, ранозаживляющим действием (наружно).\n6. Детские гели и шампуни, пантенол, косметика`,\n    \"Rubia tinctorum\": `**Марена красильная –** _ **Rubia tinctorum** _\n\n_ **Rubiae rhizoma et radix.** _\n\n_ **Rubiaceae.** _\n\nМноголетник. произрастают в Средиземноморье, на Кавказе.\n\nРанней весной-март-апрель или в конце вегетации (до начала заморозков). Не обмывая корни и корневища.\n\n**Химический состав**. **Руберитриновая кислота, ализарин, рубиадин** ; флавоноиды, иридоиды, органические кислоты.\n\n**Действие** : литолитическое, спазмолитическое, мочегонное, противовоспалительное. Применяют при мочекаменной болезни, кристаллурии, спазмах мочеполового тракта.\n\nРазрыхляет и разрушает фосфатные и оксалатные камни почек и мочевого пузыря на более мелкие. Понижает тонус и усиливает перестальтику мускулатуры почечных лоханок и мочеточников, способствуя продвижению и выведению мелких конкрементов и песка.\n\nЛС: сырье, Цистенал(капли для приема внутрь, настойка марены, магния салицилат, эфирные масла), Марелин(-), цистон(+, индия, таблетки)\n\n**ЛР И ЛРС, содержащие конденсированные антраценпроизводные**`,\n    \"Hypericum perforatum\": `**Зверобой продырявленный (З.обыкновенный) –**_ **Hypericum perforatum** _\n\n**Зверобой пятнистый(З.четырехгранный) –**_**Hypericum maculatum (H.quadrangulum**_**).**\n\n_ **Hyperici herba.** _\n\n_ **Hypericaceae** _\n\nВ РБ есть. Заготовка –во время цветения до появления плодов, длинной 25-30 см (облиственные верхушки), без грубых стеблей. Недопустимо вырывать с корнями растение.\n\n**Химический состав** _ **.** _ **Гиперицин, псевдогиперицин;** флавоноиды, дубильные вещества, эфирное масло, алкалоиды, вит.С.\n\n**Действие:** Фотосенсибилизирующее, вяжущее, **антимикробное,** противовирусное, противовоспалительное, желчегонное (усиливает отток желчи), спазмолитическое, **антидепрессивное,** анксиолитическое, гипогликемическое, восстанавливает нормальную перистальтику кишечника, диуретическое, ранозаживляющее.\n\nПрименяют в комплексном лечении воспалительных заболеваний полости рта, глотки и симптоматическом лечении легкого дискомфорта в области желудочно-кишечного тракта. С 12 лет.\n\n**ЛС:**\n\nСырье( падис, биотест, калина, беласептика), таблетки, настойка\n\nДиагиперон(ферейн+ - настойка - Применяют при мягкой и умеренной депрессии, апатии, нарушении сна, беспокойствах, дискомфорте. Для профилактики и лечения ангины и тонзилитах, при ссадинах и ушибах. С 12 лет.)\n\nСеданол(пустырник, валериана. Зверобой, синюха, + ферейн)\n\nФитолит(капсулы, таблетки, -) Гербогастрин(-) Диаротоканплюс(-) Ново-пассит(+ чехия), сбор Арфазетин(+украина), АлвисанНЕО(+Чехия)`,\n    \"Arctostaphylos uva-ursi\": `**Толокнянка обыкновенная (Медвежье ушко)- Arctostaphylos uva ursi )** \n\n**Uvae ursi folium**\n\n**Толокнянки побеги - Uvae ursi cormus**\n\n**Вересковые- Ericaceae**\n\nВечнозеленый многолетник. Распространен от Дальнего Востока до Карпат.\n\nСбор проводят в два срока: весной–до цветения или в самом начале и осенью–с момента созревания плодов до их осыпания, до появления снежного покрова. Нельзя заготавливать с середины июля до конца августа, т.к. сырье буреет  и в нем меньше арбутина. Толокнянка медленно растущее растение –интервал между сборами 3-5 лет.\n\n**Химический состав*.*** Фенольный гликозид **арбутин, метиларбутин, гидрохинон**;  дуб в-ва, урсоловая кислота, флавоноиды, аминокислоты, иод.\n\n**Действие**: уроантисептическое – применяется для дезинфекции мочевыводящих путей при циститах, уретритах. НЕ ПРИМЕНЯТЬ БОЛЬШЕ НЕДЕЛИ. Моча окрашивается в зеленый цвет. С 12 лет\n\n**ЛС:** мочегонный сбор №2(+ падис, беласептика), сырье( + падис, биотест, беласептика)\n\n**Противопоказания:**  Заболевания почек гломерулонефрит , пиелит, тяжелые заболевания печени и почек. \n`,\n    \"Vaccinium vitis-idaea\": `**Брусника обыкновенная –Vaccinium vitis-idaea**\n\n**Vaccinii vitis-idaeae folium**,\n\nБрусники побеги –**Vaccinii vitis-idaeae cormus**.\n\n**Vacciniaceae.**\n\nВечно зеленый кустарник. от Дальнего Востока до Балтики и от Белого до Черного моря.\n\nЗаготовка аналогично толокнянке. Весной –до цветения. Осенью –после полного созревания плодов. \n\n**Химический состав*.* Арбутин, гидрохинон, метиларбутин,** дубильные вещества, флавоноиды,  урсоловая кислота, каротиноиды, витамин С.\n\n**Действие:** уроантисептическое(противовоспалительное), диуретическое – при дезинфекции мочевыводящих путей при циститах, уретритах. С 12 лет![](Aspose.Words.cf79e2b1-19f1-4547-82b0-e9b407ec8c66.001.jpeg)\n\nЛС: сырье(калина, падис, биотест, беласептика)`,\n    \"Rhodiola rosea\": `**Родиола розовая (Золотой корень)  –Rhodiola rosea** \n\n**Родиолы розовой корневища и корни –Rhodiolae roseae rhizoma et radix.**\n\n**Толстянковые –Crassulaceae.**\n\nМноголетнее суккулентное двудомное растение. от тундры европейской части СНГ до Алтая, Забайкалья и Дальнего Востока. \n\nС конца цветения и до конца вегетации растения. Не подлежат заготовке молодые растения с 1-2 стеблями. Высушенное сырье на изломе розовое. Сушка на солнце недопустима.\n\n**Химический состав*.*** фенолоспирт - салидрозид; фенилпропаноиды – розавин, флавоноиды, дубильные вещества, эфирное масло – цитраль, коричный альдегид, микроэлементы, орг. к-ты\n\n**Действие:** тонизирующее, адаптогенное – повышает устойчивость организма к неблагоприятным воздействиям, физ., умственную работоспособность, способствует восстановлению жизнедеятельности организма после перенесенных заболеваний. Стимулирующее ЦНС, иммуномодулирующее, противовоспалительное, бактерицидное. Активирует функцию щитовидной железы. Снижает содержание молочной кислоты в мышцах.\n\n**ЛС:**  Настойка, бады, экстракт жидкий - улучшает энергетическое обеспечение мозга, регулирует уровень глюкозы в крови, косметические средства (крема и т.д.).`,\n    \"Salix acutifolia\": `**Ива остролистная (И. белая (серебристая) - Salix acutifolia, S. alba, S.caprea(козья)**\n\n**Salicis cortex**\n\n**Salicis folium (???????)**\n\n**Salicaceae**\n\nДвудомные виды, представляющие собой деревья и кустарники. Встречается повсеместно на территории СНГ. \n\nСобирают с двух-трехлетних ветвей в апреле —июне в период сокодвижения, подвяливают на солнце и досушивают в сушилке при температуре 50—60 ºС (ломается, а не гнется).\n\n**Химический состав*.*** Фенолгликозиды: салицин, саликорцил, салициловый спирт, флавоноиды, дубильные в-ва, смолистые соед., орг. к-ты\n\n**Действие:** жаропонижающее, противоспалительное, тонизирующее. Применяют при простудных заболеваниях, сопровождающихся лихорадкой, воспалениях ротовой полости, верхних дыхательных путей и кожи.\n\n**ЛС:** инсти(+, пакистан), сырье`,\n    \"Schizandra chinensis\": `**Лимонник китайский - Schizandra chinensis** \n\n**Schizandrae chinensis semen**\n\n**Schizandrae chinensis fructus**\n\n**Schizandraceae**\n\nДревесная лиана. Произрастает на Сахалине, Дальнем Востоке, в Северном Китае, Корее.\n\nЗаготовка –в период полного созревания (до заморозков). \n\nСемена –после отжима сока из кистей с плодами, отжатую мякоть увлажняют, помещают в бочки и оставляют для брожения в теплом месте. Через 3-5 дней помещают на решетку и сильной струей воды отмывают. Сушат при 50 ºС. Высушенные семена очищают от примесей.\n\n**Химический состав.** Лигнаны: схизандрин, изосхизандрин, дезоксисхизандрин, гомизины А, B, C, D, F, G, H, I, N,  органические кислоты, эфирные и жирные масла, дубильные вещества\n\n**Действие:** тонизирующее, адаптогенное. гепатопротекторное. Улучшает цветоразличение.\n\nПрименяют при физической и умственной усталости, астении, депрессии, при ОРВИ. Увеличивает остроту слуха, кожную чувствительность, рефлекторное возбуждение спинного мозга, нормализует секрецию желудочного сока.\n\nЛС: сироп лимонника бад`,\n    \"Eleutherococcus senticosus\": `**Элеутерококк (Свободноягодник) колючий -Eleutherococcus senticosus** \n\n**Araliaceae**\n\n**Eleutherococci rhizome et radix**\n\n**Многоствольный кустарник**. **В РБ в агрокультуре.**\n\nосенью во второй половине сентября у взрослых развитых растений высотой более 1 м, моют быстро, рубят на куски и сушат на чердаках или при 70-80 ºС. \n\n**Химический состав:** *лигнаны:*** сирингарезинол, элеутерозиды (их 8 - относятся к тритерпеновым сапонинам, кумаринам и лигнанам), элеутерозид В (сирингин)\n\n**Действие:** общетонизирующее, адаптогенное, иммуномодулирующее (увеличивает число Т-лимфоцитов), гипогликемическое\n\n**ЛС:** \n\n1. *БАДы в виде таблеток, драже, настойки* - при переутомлении, раздражительности, физической и умственной усталости, реконвалесценции (после соматических и инфекционных заболеваний), артериальной гипотонии, ипохондрии. Назначают при тяжелых проявлениях климакса, при вазомоторных расстройствах, нарушениях менструального цикла. Увеличивает остроту слуха и зрения\n1. **Элеутерококка жидкий экстракт** (спиртовое извлечение, Ферейн+) – стимулирующее на ЦНС, повышение физической и умственной работоспособности при астенических состояниях, переутомлении\n1. **Арфазетин** (сбор (побеги черника, плоды фасоли, шиповника, корни элеутерококка (аралия, заманиха, женьшень), трава хвоща, зверобоя, цветы ромашки) Украина +) – комплексная терапия сахарного диабета 2 типа легкой степени тяжести,*`,\n    \"Silybum marianum\": `**Расторопша пятнистая (Остро-пёстро) - Silybum marianum** \n\n**Asteraceae**\n\n**Silybi mariani fructus**\n\n**Травянистое. В РБ в агрокультуре**\n\nВ период засыхания обверток на большинстве боковых корзинок в августе-сентябре. Скашивают надземную часть, сушат на току и обмолачивают. Затем плоды очищают от примесей и досушивают. Хранят в специальной кладовой для семян и плодов.\n\n**Химический состав:** *Флаволигнаны*: силибин (силибинин), силидианин, силикристин; ЖМ, биогенные амины (гистамин, тирамин), флавоноиды (кверцетин, дигидрофлаванол, таксифолин), макро-и микроэлементы.\n\n**Действие:** Гепатопротекторное, желчегонное, иммуномодулирующее, антиоксидантное, лактогенное. При токсических поражениях, хронических воспалительных заболеваниях печени или циррозе печени.\n\n**ЛС:** \n\n1. **Сырье** (Биотест+) – отвары для лечения заболеваний печени и желчевыводящих путей. \n1. **Сухой экстракт** (Китай, Италия, Белмедпрепараты +) \n1. *Масло расторопши как БАД, также в капсулах*\n1. *Шрот расторопши как БАД в виде порошка* – перемолотые семена расторопши после холодного отжима из них масла. Усиливает перистальтику и благоприятен для микрофлоры.\n1. **Силибор 35** (таблетки с сухим экстрактом, Украина+) - для симптоматического лечения хронических токсических поражений печени; для поддерживающего лечения у пациентов с хроническими воспалительными заболеваниями печени или циррозом печени. С 12 лет. При одновременном применении силимарина и пероральных контрацептивных средств и препаратов, применяемых при эстроген-заместительной терапии, возможно снижение эффективности последних.\n1. **Легалон 140** (капсулы с сухим экстрактом, Германия+), **Гепсил-Рн** (таблетки, Рубикон+), **Силимарин** (таблетки, БЗМП+), **Карсил** (таблетки, капсулы, Болгария+)\n1. *Агастацин* (настойка на расторопшеи многоколоснике, Диалек-)\n1. *Биеносилим* (капсулы, Белмедпрепараты-)\n1. **Иберогаст** (капли из экстракта (ибериса, травы чистотела, корня дягиля, солодки, цветки ромашки, листьев мяты, мелиссы, плодов тмина и расторопши) Германия+) – для лечения ЖКТ расстройств (диспепсия, синдром раздраженного кишечника, гастрит`,\n    \"Podophyllum peltatum\": `**Подофилл щитовидный**\n\n**Podophyllum peltatum - Berberidaceae**\n\nPodophylli rhizoma cum radicibus\n\n**Эндемик Северной Америки.** \n\nс 3-5-летних плантаций осенью или весной. Сушат на чердаках или при 40 ºС. Хранят как сильнодействующее.\n\n**Химический состав:** *Лигнаны* *тетрагидронафталинового типа*: подофиллотоксин, пельтатины.\n\n**Действие:** Цитостатическое, желчегонное, слабительное, некротизирующее (местно), прижигающее, противоопухолевое. Применяют при папилломматозе. Подофиллотоксин-митотический яд -тормозит деление опухолевых клеток. Применяют в виде 5-25% спиртового раствора (на 90% спирте) или масляной суспензии подофиллина или мази при лечении остроконечных кондилом. Применяют также папиломме гортани и мочевого пузыря (экспериментальные работы) \n\n**Нельзя во время** **беременности**\n\n**Побочные реакции:** при введении в мочевой пузырь ощущают боль в низу живота, чувство жжения в области мочевого пузыря, расстройство мочеиспускания; при смазывании участков гортани—тошноту, рвоту и расстройство ЖКТ.\n\n**ЛС:** *Подофиллин*`,\n    \"Astragalus dasyan\": `**Астрагал шерстистоцветковый - Astragalus dasyan**\n\n**Астрагала шерстистоцветкового трава - Astragali dasyanthi herba**\n\n**Fabaceae**\n\n**Содержит тетрациклические тритерпеновые сапонины, производные циклоартана**\n\nМноголетник.\n\nВ период массового цветения до образования плодов, срезая (не срывая повреждаются почки возобновления). Сушат при 55 ºС\n\n**Химический состав:** Дазиантозиды А, В, С, производные дазиантогенина; флавоноиды (кверцетин, кемпферол, изорамнетин), дубильные вещества\n\n**ЛС: настой из сырья которое у нас не продают**\n\n**Действие:** Гипотензивное, диуретическое. Применяют при начальных формах артериальной гипертензии, недостаточности кровообращения и сердечной недостаточности, при хронической недостаточности кровообщращения.`,\n    \"Tribulus terrestris\": `**Якорцы стелющиеся- Tribulus terrestris**\n\n**Якорцев стелющихся трава Tribuli terrestris herba**\n\n**Zygophyllaceae**\n\n**Содержит стероидные сапонины, производные диосгенина**\n\nОднолетник. \n\n**Химический состав:** Триллин , диосцин , протодиосцин ,грациллин ; флавоноиды, дубильные вещества, алкалоиды.\n\n**Действие:** Гипотензивное, мочегонное, антисклеротическое. Применяют при бесплодии, половых дисфункциях, дислипопротеинемии (при необходимости снижения уровня ЛПНП и холестерина) и как общетонизирующее средство. Увеличивает количество сперматозоидов и их подвижность, улучшает эрекцию. Снижает давление, применяется при ИБС. Ингибирует альфа глюкозидазу в кишечнике, что снижает всасывание сахара.\n\n**ЛС:** \n\n1. Спеман (таблетки, - ятрышник мужской, астеркант длиннолистый, латук компасный, мозаичное золото, аргирея красивая, якорцы стелющиеся, лептадений сетчатый, пармелия жемчужная, бархатные зудящие бобы). - Препарат стимулирует сперматогенез, повышает подвижность сперматозоидов, снижает вязкость спермы. При остром и хроническом воспалении простаты.\n1. Жидкий экстракт\n1. Трибестан(Болгария+)- эректильная дисфункция, в т.ч. сопровождающаяся снижением либидо; бесплодие у мужчин, для снижения уровня общего холестерина.\n1. Трибуспонин(-)`,\n    \"Leuzea carthamoides\": `**Левзеи сафлоровидной листья - Rhapontici carthamoides folium**\n\n**Левзеи сафлоровидной корневища с корнями Rhapontici carthamoides rhizoma cum radicibus**\n\n**Левзея сафлоровидная (Маралий корень, рапонтикум сафлоролоровидный) Leuzea carthamoides (Rhaponticum carthamoides)**\n\n**Asteraceae.**\n\n**Содержит фитоэкдизоны**\n\nМноголетник. в Беларуси культивируется.\n\n**Химический состав:** Фитоэкдизоны (экдистероиды ) : экдистерон , инокостерон , интегристероны А, В; рапонтозиды , лигнаны , эфирное масло, флавоноиды, дубильные вещества, органические кислоты. \n\n**Действие:** Стимулирующее ЦНС (психостимулятор), общетонизирующее , адаптоген .Усиливают синтез белка (анаболик). Рекомендуется к применению для: адаптации организма к повышенным физическим и умственным нагрузкам, усиления работоспособности, восстановления после тяжелых заболеваний и истощения, снижения чувства утомления, раздражительности, повышения либидо и потенции.\n\n**ЛС:** жидкий экстракт, экдистен(-) - астенический синдром, связанный с ослаблением белоксинтезирующих процессов; при длительных интоксикациях, инфекциях; умственное и физическое переутомление; у спортсменов, в качестве лекарственного средства повышающего скоростно-силовые качества в период подготовки к соревнованиям. Бад Левзея.`,\n    \"Digitalis purpurea\": `**Наперстянка пурпурная – Digitalis purpurea** \n\n\\` \\`**Digitalis purpureaе folium.**\n\n**Scrophulariaceae**\n\nПроизрастает в Западной Европе, Карпатах. Во флоре Беларуси в диком виде не отмечено, но иногда культивируется как декоративное. Собирают розеточные листья первогогода и стеблевые листья второго года.\n\n**Химический состав.** Сердечные гликозиды: ***Пурпуреагликозиды*** ***А, В***, глюкогиталоксин; ***дигитоксин, гитоксин***, ***гиталоксин***; стероидные сапонины (до 2%), флавоноиды, иридоиды (до 5%), фенолкарбоновые к-ты.`,\n    \"Digitalis grandiflora\": `**Наперстянка  крупноцветковая –  Digitalis grandiflora,**\n\n**Digitalis folium**\n\n**Scrophulariaceae.**\n\n**Химический состав.** Ланатозиды А, В, С, стероидные сапонины, флавоноиды.`,\n    \"Digitalis lanata\": `**Наперстянка шерстистая – Digitalis lanata**\n\n\\` \\`**Digitalis lanatae folium,**\n\n**Scrophulariaceae**\n\nМноголетнее травянистое растение. В культуре выращивается обычно как двулетнее растение. Естественно произрастает на Кавказе, Балканах, но считается редким, исчезающим видом. В Беларуси известно только в культуре.\n\n**Химический состав.** Сердечные гликозиды: ***Ланатозиды (дигиланиды) А, В, С, D, ацетилдигитоксин, ацетилгитоксин, ацетилдигоксин; дигитоксин, дигитоксигенин, гитоксин,*** стероидные сапонины, флавоноиды, витамины, фенолкарбоновые кислоты.\n\n**ЛС:** \n\n**Дигоксин** – (таблетки по 0.25 мг, Фармлэнд +, по рецепту!, есть инъекционные формы в ампулах) Действие кардиотоническое. – относится к кардиологическим препаратам группы сердечных гликозидов. Увеличивает сократимость миокарда, уменьшает ЧСС. Применяется при застойной сердечной недостаточности, мерцании, трепетании предсердий, пароксизмальной тахикардии. Применяют начиная с нагрузочной дозы, затем поддерживающую. Схемы применения у детей до и после 10 лет различны.\n\nПобочные эффекты (мало ли новое требование будет)): учащенное сердцебиение, боль в груди, затрудненное дыхание или потоотделение; замедление или сбой сердечного ритма; плохое самочувствие или диарея; сыпь на коже, которая может зудеть; сонливость или головокружение; проблемы со зрением: размытое, или желто-зеленое восприятие окружающего; замедленная или неравномерная скорость сердца и др.\n\n***Целанид КМП*** – (Украина, табл, -) – кардиотоническое средство, показания к применению такие как у дигоксина.`,\n    \"Strophantus  kombe\": `**Строфант Комбе - Strophantus  kombe**\n\n**Strophanthi semen**\n\n\\` \\`**Apocynaceae**\n\nМноголетняя лиана. Произрастает в тропиках Африки.\n\n**Химический состав. Сердечные гликозиды:** ***К-строфантозид, К-строфантин-ß, цимарин, строфантидин, цимарин, жирное масло, сапонины.*** \n\n**ЛС**.\n\n**Строфантин Г** (раствор для инъекций 0,025% 1мг №10, Украина +, по рецепту) – в составе комплексной терапии острой и хронической сердечной недостаточности, при мерцании и трепетании предсердий пароксизмального и хронического течения. Влияет на калиево-натриевый насос кардиомиоцитов. С 15 лет. Повышает силу и скорость сердечных сокращений.\n\n**Фармакологическое действие и применение**. Кардиотоническое. Для лечения острой сердечной недостаточности.`,\n    \"Adonis vernalis\": `**Горицвет весенний (Адонис) - Adonis vernalis** \n\n**Adonidis vernalis herba.**\n\n**Ranunculaceae**\n\nМноголетник. Естественно произрастает в лесостепной и степной зонах, в Беларуси культивируется.\n\nВ период  плодоношения срезают 7-10 см от поверхности почвы выше коричневых чешуй. Побеги не выдергивают и не обрывают, чтобы не повредить точки возобновления. Скашивают или срезают со всеми растениями, а затем выбирают побеги горицвета. Сушат на продуваемых стеллажах под навесом либо в сушилках при температуре 40—50 ºС.\n\n**Химический состав.** Сердечные гликозиды: **адонитоксин,** строфантидин, цимарин, адонитоксигенин,  флавоноиды, кислоты, спирт адонит.\n\n**Фармакологическое действие и применение**. Кардиотоническое, успокаивающее. Применяют при начальных стадиях хронической сердечной недостаточности, раздражительности.\n\n**ЛС:**\n\n**Фиточай, сырье ангро (россия)**\n\n**Адонис-бром** (БЗМП, -, таблетки, покрытые оболочкой КBr + густой экстракт горицвета, без рецепта) – действие кардиотоническое, седативное, применяется при начальной стадии хронической сердечной недостаточности, раздражительности.`,\n    \"Convallaria majalis\": `**Ландыш майский (Язык лесной) - Convallaria  majalis**\n\n**Convallariae herba,**\n\n**Convallariae folium,**\n\n**Convallariae flos,**\n\n**Convallariaceae**\n\nМноголетник. \n\nТрава и цветки – во время цветения, листья – до и в начале цветения. Траву и листья срезают на 3-5 см выше почвы, выше бурых чешуй (почки возобновления). Цветочные кисти срезают отступая примерно 3 см  от нижнего цветка в соцветии. Сушат при 40-50. Конец сушки по ломкости.\n\n**Химический состав.** ***Конваллотоксин, конваллотоксол, конваллозид;*** стероидные сапонины, флавоноиды (производные кверцетина, кемпферола, лютеолина), эфирное масло (фарнезол).\n\n**Фармакологические свойства и применение**. Кардиотоническое, желчегонное.  Кратковременного действия (максимум 30 мин). Применяют при острой и хронической  сердечной недостаточности при непереносимости наперстянки.\n\n**ЛС**:\n\n**Коргликон (**р-р для инъекций 0.6 мг/мл в ампулах 1 мл в упаковке №10, по рецепту, +, Украина) – применяется при острой и хронической сердечно-сосудистой недостаточности, при  непереносимости препаратов наперстянки. Препарат имеет седативное влияние на центральную нервную систему.\n\n**Капли Зеленина** (+, Украина, красавка, ландыш, валериана, ментол, капли для приема внутрь) – в комплексной терапии нейроциркуляточной дистонии, хронической сердечной недостаточности, сопровождающейся синусовой брадикардией.`,\n    \"Erysimum diffusum\": `**Желтушник раскидистый (Ж. серый) - Erysimum  diffusum (E. canescens )**\n\n**Erysimi diffusi herba recens,**\n\n**Erysimi diffusi semen.**\n\n**Brassicaceae.**\n\nКультивируется, двулетник. Траву скашивают во время цветения, доставляют на завод не позднее 48 часов после сбора, далее немедленная переработка.\n\n**Химический состав.** Трава. Сердечные гликозиды - **Эризимозид, эризимин, глюкоэризимозид,** флавоноиды (производные кверцетина, изорамнетина)\n\nСемена. **Сердечные гликозиды - эризимозид, гликозиды строфантидина, масло (30-40%).**\n\n**Фармакологическое действие и применение**. Кардиотоническое. Применяют при острой и хронической сердечной недостаточности II—III степени с тяжелым нарушением кровообращения. При ревматических пороках сердца.\n\n**ЛС:**\n\n\\` \\`Сок, Кардиовален(-, капли для приема внутрь – седативное и кардиотоническое действие) из травы, строфандитина ацетат (семена)`,\n    \"Hypericum maculatum\": \"\",\n    \"Glycyrrhiza uralensis\": \"\",\n    \"Salix alba\": \"\",\n    \"LRS\": \"Тут нечего писать\"\n};\nfunction same(plant, as) {\n    plantsDescriptions[plant] = plantsDescriptions[as];\n}\nsame(\"Hypericum maculatum\", \"Hypericum perforatum\");\nsame(\"Glycyrrhiza uralensis\", \"Glycyrrhiza glabra\");\nsame(\"Salix alba\", \"Salix acutifolia\");\nconst lessons = [{\n        header: \"saponins\",\n        plants: [\n            \"Polemonium caeruleum\",\n            \"Hedera helix\",\n            \"Primula veris\",\n            \"Polemonium caeruleum\",\n            \"Dioscorea nipponica\",\n            \"Dioscorea nipponica\",\n            \"Dioscorea nipponica\",\n            \"Panax ginseng\",\n            \"Aesculus hippocastanum\",\n            \"Aralia mandshurica\",\n            \"Glycyrrhiza glabra\",\n            \"Glycyrrhiza glabra\",\n            \"Primula veris\",\n            \"Hedera helix\",\n            \"Aesculus hippocastanum\",\n            \"Что это?\",\n            \"Glycyrrhiza glabra\",\n        ]\n    },\n    {\n        header: \"anthracens\",\n        plants: [\n            \"Rumex confertus\",\n            \"Frangula alnus\",\n            \"Rheum palmatum\",\n            \"Rubia tinctorum\",\n            \"Rhamnus cathartica\",\n            \"Hypericum perforatum\",\n            \"Hypericum maculatum\",\n            \"Rheum palmatum\",\n            \"Rubia tinctorum\",\n            \"Hypericum perforatum\",\n            \"Rumex confertus\",\n            \"Aloe arborescens\",\n            \"Frangula alnus\"\n        ]\n    },\n    {\n        header: \"kolok3\",\n        plants: [\n            \"Dioscorea nipponica\",\n            \"Glycyrrhiza glabra\",\n            \"Rhamnus cathartica\",\n            \"Rhamnus cathartica\",\n            \"Leuzea carthamoides\",\n            \"Hypericum maculatum\",\n            \"Panax ginseng\",\n            \"Aralia mandshurica\",\n            \"Glycyrrhiza uralensis\",\n            \"Frangula alnus\",\n            \"Dioscorea nipponica\",\n            \"Salix alba\",\n            \"Rubia tinctorum\",\n            \"Hypericum perforatum\",\n            \"Schizandra chinensis\",\n            \"Arctostaphylos uva-ursi\",\n            \"Rumex confertus\",\n            \"Vaccinium vitis-idaea\",\n            \"Rheum palmatum\",\n            \"Frangula alnus\",\n            \"Silybum marianum\",\n            \"Salix acutifolia\",\n            \"Eleutherococcus senticosus\",\n            \"Convallaria majalis\",\n            \"Polemonium caeruleum\",\n            \"Primula veris\",\n            \"Aesculus hippocastanum\",\n            \"Glycyrrhiza glabra\",\n            \"Hedera helix\",\n            \"Erysimum diffusum\",\n            \"Digitalis grandiflora\",\n            \"Digitalis lanata\",\n            \"Podophyllum peltatum\",\n            \"Digitalis purpurea\",\n            \"Erysimum diffusum\",\n            \"Adonis vernalis\",\n            \"LRS\",\n            \"LRS\",\n            \"LRS\",\n            \"Leuzea carthamoides\",\n            \"LRS\",\n            \"LRS\",\n            \"LRS\",\n            \"LRS\",\n            \"LRS\",\n            \"LRS\",\n            \"LRS\"\n        ]\n    }\n];\n\n\n//# sourceURL=webpack://study/./src/scripts/data.ts?");

/***/ }),

/***/ "./src/scripts/hydrateSelect.ts":
/*!**************************************!*\
  !*** ./src/scripts/hydrateSelect.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data */ \"./src/scripts/data.ts\");\n\nconst $select = document.querySelector(\"#lesson_name\");\nif ($select !== null) {\n    _data__WEBPACK_IMPORTED_MODULE_0__.lessons.forEach(lesson => {\n        $select.innerHTML += `\n    <option>${lesson.header}</option>  \n  `;\n    });\n}\nelse {\n    throw \"Lesson select not found\";\n}\n\n\n//# sourceURL=webpack://study/./src/scripts/hydrateSelect.ts?");

/***/ }),

/***/ "./src/scripts/index.ts":
/*!******************************!*\
  !*** ./src/scripts/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! marked */ \"./node_modules/marked/lib/marked.esm.js\");\n/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data */ \"./src/scripts/data.ts\");\n/* harmony import */ var _hydrateSelect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hydrateSelect */ \"./src/scripts/hydrateSelect.ts\");\n\n\n\nconst lessonsHydrated = Object.fromEntries(_data__WEBPACK_IMPORTED_MODULE_1__.lessons.map(lesson => {\n    return [\n        lesson.header,\n        { plants: lesson.plants.map(plantToCard(lesson)) }\n    ];\n}));\nfunction plantToCard(lesson) {\n    return function (plant, index) {\n        const $card = document.createElement(\"div\");\n        $card.className = \"card\";\n        $card.innerHTML = `\n  <p>${index + 1} из ${lesson.plants.length} ${lesson.header}</p>\n  <img class=\"card_img\" src=\"static/${lesson.header}/${index}.jpg\" alt=\"\">\n  <div class=\"card_description\">${marked__WEBPACK_IMPORTED_MODULE_0__.marked.parse(_data__WEBPACK_IMPORTED_MODULE_1__.plantsDescriptions[plant] || \"\")}</div>\n  `;\n        const card = {\n            plant,\n            index,\n            lesson,\n            $card,\n        };\n        $card._custom = { card };\n        return card;\n    };\n}\ndocument.addEventListener(\"click\", e => {\n    const target = e.target;\n    if (!(target.classList.contains(\"card\") || target.closest(\".card\")))\n        return;\n    const $card = target.classList.contains(\"card\") ? target : target.closest(\".card\");\n    if ($card !== null) {\n        $card.classList.toggle(\"open\");\n    }\n});\nconst $cardContainer = document.querySelector(\"#card_container\");\nif ($cardContainer === null)\n    throw \"Card container not found\";\nconst $randomButton = document.querySelector(\"#random_button\");\nif ($randomButton === null)\n    throw \"Random button not found\";\n$randomButton.addEventListener(\"click\", e => {\n    clearCard();\n    const cards = Object.values(lessonsHydrated).flatMap(lesson => lesson.plants);\n    const $card = cards[Math.floor(Math.random() * cards.length)].$card;\n    $cardContainer.append($card);\n});\nconst $currentLesson = document.querySelector(\"#lesson_name\");\nif ($currentLesson === null)\n    throw \"Current lesson not found\";\n$currentLesson.addEventListener(\"change\", e => {\n    setCard(lessonsHydrated[$currentLesson.value].plants[0].$card);\n});\nconst $lessonRandomButton = document.querySelector(\"#lesson_random_button\");\nif (!$lessonRandomButton)\n    throw \"Lesson random button not found\";\n$lessonRandomButton.addEventListener(\"click\", e => {\n    const plants = lessonsHydrated[$currentLesson.value].plants;\n    const $card = plants[Math.floor(Math.random() * plants.length)].$card;\n    setCard($card);\n});\nfunction clearCard() {\n    var _a, _b;\n    if ($cardContainer === null)\n        return;\n    (_b = (_a = $cardContainer.querySelector(\".card\")) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.remove(\"open\");\n    $cardContainer.innerHTML = \"\";\n}\nfunction setCard($card) {\n    if ($cardContainer === null)\n        return;\n    clearCard();\n    $cardContainer.append($card);\n}\nfunction getCurrentCard() {\n    const $card = document.querySelector(\".card\");\n    if ($card === null) {\n        console.warn(\"card is null\");\n        return null;\n    }\n    return $card._custom.card;\n}\nconst $lessonNextButton = document.querySelector(\"#lesson_next_button\");\nif (!$lessonNextButton)\n    throw \"Lesson next button not found\";\n$lessonNextButton.addEventListener(\"click\", e => {\n    const card = getCurrentCard();\n    if (card === null)\n        return;\n    const index = (card.index + 1) % card.lesson.plants.length;\n    setCard(lessonsHydrated[card.lesson.header].plants[index].$card);\n});\nconst $prevButton = document.querySelector(\"#lesson_prev_button\");\nif ($prevButton === null)\n    throw \"Prev button not found\";\n$prevButton.addEventListener(\"click\", e => {\n    const card = getCurrentCard();\n    if (card === null)\n        return;\n    const index = card.index === 0 ? card.lesson.plants.length - 1 : card.index - 1;\n    setCard(lessonsHydrated[card.lesson.header].plants[index].$card);\n});\nconst $testName = document.querySelector(\"#test_name\");\nif ($testName === null)\n    throw \"Test name not found\";\n$testName.addEventListener(\"input\", e => {\n    var _a;\n    const plant = (_a = getCurrentCard()) === null || _a === void 0 ? void 0 : _a.plant;\n    if (!plant)\n        return;\n    const target = e.target;\n    if (target.value !== plant)\n        $testName.classList.add(\"invalid\");\n    else\n        $testName.classList.remove(\"invalid\");\n});\n\n\n//# sourceURL=webpack://study/./src/scripts/index.ts?");

/***/ }),

/***/ "./node_modules/marked/lib/marked.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/marked/lib/marked.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Lexer\": () => (/* binding */ Lexer),\n/* harmony export */   \"Parser\": () => (/* binding */ Parser),\n/* harmony export */   \"Renderer\": () => (/* binding */ Renderer),\n/* harmony export */   \"Slugger\": () => (/* binding */ Slugger),\n/* harmony export */   \"TextRenderer\": () => (/* binding */ TextRenderer),\n/* harmony export */   \"Tokenizer\": () => (/* binding */ Tokenizer),\n/* harmony export */   \"defaults\": () => (/* binding */ defaults),\n/* harmony export */   \"getDefaults\": () => (/* binding */ getDefaults),\n/* harmony export */   \"lexer\": () => (/* binding */ lexer),\n/* harmony export */   \"marked\": () => (/* binding */ marked),\n/* harmony export */   \"options\": () => (/* binding */ options),\n/* harmony export */   \"parse\": () => (/* binding */ parse),\n/* harmony export */   \"parseInline\": () => (/* binding */ parseInline),\n/* harmony export */   \"parser\": () => (/* binding */ parser),\n/* harmony export */   \"setOptions\": () => (/* binding */ setOptions),\n/* harmony export */   \"use\": () => (/* binding */ use),\n/* harmony export */   \"walkTokens\": () => (/* binding */ walkTokens)\n/* harmony export */ });\n/**\n * marked - a markdown parser\n * Copyright (c) 2011-2022, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\nfunction getDefaults() {\n  return {\n    async: false,\n    baseUrl: null,\n    breaks: false,\n    extensions: null,\n    gfm: true,\n    headerIds: true,\n    headerPrefix: '',\n    highlight: null,\n    langPrefix: 'language-',\n    mangle: true,\n    pedantic: false,\n    renderer: null,\n    sanitize: false,\n    sanitizer: null,\n    silent: false,\n    smartypants: false,\n    tokenizer: null,\n    walkTokens: null,\n    xhtml: false\n  };\n}\n\nlet defaults = getDefaults();\n\nfunction changeDefaults(newDefaults) {\n  defaults = newDefaults;\n}\n\n/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, 'g');\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\nconst escapeReplacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nfunction escape(html, encode) {\n  if (encode) {\n    if (escapeTest.test(html)) {\n      return html.replace(escapeReplace, getEscapeReplacement);\n    }\n  } else {\n    if (escapeTestNoEncode.test(html)) {\n      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n    }\n  }\n\n  return html;\n}\n\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\n/**\n * @param {string} html\n */\nfunction unescape(html) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(unescapeTest, (_, n) => {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nconst caret = /(^|[^\\[])\\^/g;\n\n/**\n * @param {string | RegExp} regex\n * @param {string} opt\n */\nfunction edit(regex, opt) {\n  regex = typeof regex === 'string' ? regex : regex.source;\n  opt = opt || '';\n  const obj = {\n    replace: (name, val) => {\n      val = val.source || val;\n      val = val.replace(caret, '$1');\n      regex = regex.replace(name, val);\n      return obj;\n    },\n    getRegex: () => {\n      return new RegExp(regex, opt);\n    }\n  };\n  return obj;\n}\n\nconst nonWordAndColonTest = /[^\\w:]/g;\nconst originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\n/**\n * @param {boolean} sanitize\n * @param {string} base\n * @param {string} href\n */\nfunction cleanUrl(sanitize, base, href) {\n  if (sanitize) {\n    let prot;\n    try {\n      prot = decodeURIComponent(unescape(href))\n        .replace(nonWordAndColonTest, '')\n        .toLowerCase();\n    } catch (e) {\n      return null;\n    }\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n      return null;\n    }\n  }\n  if (base && !originIndependentUrl.test(href)) {\n    href = resolveUrl(base, href);\n  }\n  try {\n    href = encodeURI(href).replace(/%25/g, '%');\n  } catch (e) {\n    return null;\n  }\n  return href;\n}\n\nconst baseUrls = {};\nconst justDomain = /^[^:]+:\\/*[^/]*$/;\nconst protocol = /^([^:]+:)[\\s\\S]*$/;\nconst domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\n/**\n * @param {string} base\n * @param {string} href\n */\nfunction resolveUrl(base, href) {\n  if (!baseUrls[' ' + base]) {\n    // we can ignore everything in base after the last slash of its path component,\n    // but we might need to add _that_\n    // https://tools.ietf.org/html/rfc3986#section-3\n    if (justDomain.test(base)) {\n      baseUrls[' ' + base] = base + '/';\n    } else {\n      baseUrls[' ' + base] = rtrim(base, '/', true);\n    }\n  }\n  base = baseUrls[' ' + base];\n  const relativeBase = base.indexOf(':') === -1;\n\n  if (href.substring(0, 2) === '//') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(protocol, '$1') + href;\n  } else if (href.charAt(0) === '/') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(domain, '$1') + href;\n  } else {\n    return base + href;\n  }\n}\n\nconst noopTest = { exec: function noopTest() {} };\n\nfunction merge(obj) {\n  let i = 1,\n    target,\n    key;\n\n  for (; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\nfunction splitCells(tableRow, count) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n      let escaped = false,\n        curr = offset;\n      while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n    cells = row.split(/ \\|/);\n  let i = 0;\n\n  // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n  if (!cells[0].trim()) { cells.shift(); }\n  if (cells.length > 0 && !cells[cells.length - 1].trim()) { cells.pop(); }\n\n  if (cells.length > count) {\n    cells.splice(count);\n  } else {\n    while (cells.length < count) cells.push('');\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n  }\n  return cells;\n}\n\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param {string} str\n * @param {string} c\n * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.\n */\nfunction rtrim(str, c, invert) {\n  const l = str.length;\n  if (l === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < l) {\n    const currChar = str.charAt(l - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.slice(0, l - suffLen);\n}\n\nfunction findClosingBracket(str, b) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1;\n  }\n  const l = str.length;\n  let level = 0,\n    i = 0;\n  for (; i < l; i++) {\n    if (str[i] === '\\\\') {\n      i++;\n    } else if (str[i] === b[0]) {\n      level++;\n    } else if (str[i] === b[1]) {\n      level--;\n      if (level < 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction checkSanitizeDeprecation(opt) {\n  if (opt && opt.sanitize && !opt.silent) {\n    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n  }\n}\n\n// copied from https://stackoverflow.com/a/5450113/806777\n/**\n * @param {string} pattern\n * @param {number} count\n */\nfunction repeatString(pattern, count) {\n  if (count < 1) {\n    return '';\n  }\n  let result = '';\n  while (count > 1) {\n    if (count & 1) {\n      result += pattern;\n    }\n    count >>= 1;\n    pattern += pattern;\n  }\n  return result + pattern;\n}\n\nfunction outputLink(cap, link, raw, lexer) {\n  const href = link.href;\n  const title = link.title ? escape(link.title) : null;\n  const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n  if (cap[0].charAt(0) !== '!') {\n    lexer.state.inLink = true;\n    const token = {\n      type: 'link',\n      raw,\n      href,\n      title,\n      text,\n      tokens: lexer.inlineTokens(text)\n    };\n    lexer.state.inLink = false;\n    return token;\n  }\n  return {\n    type: 'image',\n    raw,\n    href,\n    title,\n    text: escape(text)\n  };\n}\n\nfunction indentCodeCompensation(raw, text) {\n  const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n  if (matchIndentToCode === null) {\n    return text;\n  }\n\n  const indentToCode = matchIndentToCode[1];\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(/^\\s+/);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      const [indentInNode] = matchIndentInNode;\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    })\n    .join('\\n');\n}\n\n/**\n * Tokenizer\n */\nclass Tokenizer {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  space(src) {\n    const cap = this.rules.block.newline.exec(src);\n    if (cap && cap[0].length > 0) {\n      return {\n        type: 'space',\n        raw: cap[0]\n      };\n    }\n  }\n\n  code(src) {\n    const cap = this.rules.block.code.exec(src);\n    if (cap) {\n      const text = cap[0].replace(/^ {1,4}/gm, '');\n      return {\n        type: 'code',\n        raw: cap[0],\n        codeBlockStyle: 'indented',\n        text: !this.options.pedantic\n          ? rtrim(text, '\\n')\n          : text\n      };\n    }\n  }\n\n  fences(src) {\n    const cap = this.rules.block.fences.exec(src);\n    if (cap) {\n      const raw = cap[0];\n      const text = indentCodeCompensation(raw, cap[3] || '');\n\n      return {\n        type: 'code',\n        raw,\n        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, '$1') : cap[2],\n        text\n      };\n    }\n  }\n\n  heading(src) {\n    const cap = this.rules.block.heading.exec(src);\n    if (cap) {\n      let text = cap[2].trim();\n\n      // remove trailing #s\n      if (/#$/.test(text)) {\n        const trimmed = rtrim(text, '#');\n        if (this.options.pedantic) {\n          text = trimmed.trim();\n        } else if (!trimmed || / $/.test(trimmed)) {\n          // CommonMark requires space before trailing #s\n          text = trimmed.trim();\n        }\n      }\n\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[1].length,\n        text,\n        tokens: this.lexer.inline(text)\n      };\n    }\n  }\n\n  hr(src) {\n    const cap = this.rules.block.hr.exec(src);\n    if (cap) {\n      return {\n        type: 'hr',\n        raw: cap[0]\n      };\n    }\n  }\n\n  blockquote(src) {\n    const cap = this.rules.block.blockquote.exec(src);\n    if (cap) {\n      const text = cap[0].replace(/^ *>[ \\t]?/gm, '');\n      const top = this.lexer.state.top;\n      this.lexer.state.top = true;\n      const tokens = this.lexer.blockTokens(text);\n      this.lexer.state.top = top;\n      return {\n        type: 'blockquote',\n        raw: cap[0],\n        tokens,\n        text\n      };\n    }\n  }\n\n  list(src) {\n    let cap = this.rules.block.list.exec(src);\n    if (cap) {\n      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine,\n        line, nextLine, rawLine, itemContents, endEarly;\n\n      let bull = cap[1].trim();\n      const isordered = bull.length > 1;\n\n      const list = {\n        type: 'list',\n        raw: '',\n        ordered: isordered,\n        start: isordered ? +bull.slice(0, -1) : '',\n        loose: false,\n        items: []\n      };\n\n      bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\n      if (this.options.pedantic) {\n        bull = isordered ? bull : '[*+-]';\n      }\n\n      // Get next list item\n      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n\n      // Check if current bullet point can start a new List Item\n      while (src) {\n        endEarly = false;\n        if (!(cap = itemRegex.exec(src))) {\n          break;\n        }\n\n        if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n          break;\n        }\n\n        raw = cap[0];\n        src = src.substring(raw.length);\n\n        line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n        nextLine = src.split('\\n', 1)[0];\n\n        if (this.options.pedantic) {\n          indent = 2;\n          itemContents = line.trimLeft();\n        } else {\n          indent = cap[2].search(/[^ ]/); // Find first non-space char\n          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n          itemContents = line.slice(indent);\n          indent += cap[1].length;\n        }\n\n        blankLine = false;\n\n        if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line\n          raw += nextLine + '\\n';\n          src = src.substring(nextLine.length + 1);\n          endEarly = true;\n        }\n\n        if (!endEarly) {\n          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n\n          // Check if following lines should be included in List Item\n          while (src) {\n            rawLine = src.split('\\n', 1)[0];\n            nextLine = rawLine;\n\n            // Re-align to follow commonmark nesting rules\n            if (this.options.pedantic) {\n              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n            }\n\n            // End list item if found code fences\n            if (fencesBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new heading\n            if (headingBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new bullet\n            if (nextBulletRegex.test(nextLine)) {\n              break;\n            }\n\n            // Horizontal rule found\n            if (hrRegex.test(src)) {\n              break;\n            }\n\n            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n              itemContents += '\\n' + nextLine.slice(indent);\n            } else {\n              // not enough indentation\n              if (blankLine) {\n                break;\n              }\n\n              // paragraph continuation unless last line was a different block level element\n              if (line.search(/[^ ]/) >= 4) { // indented code block\n                break;\n              }\n              if (fencesBeginRegex.test(line)) {\n                break;\n              }\n              if (headingBeginRegex.test(line)) {\n                break;\n              }\n              if (hrRegex.test(line)) {\n                break;\n              }\n\n              itemContents += '\\n' + nextLine;\n            }\n\n            if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n              blankLine = true;\n            }\n\n            raw += rawLine + '\\n';\n            src = src.substring(rawLine.length + 1);\n            line = nextLine.slice(indent);\n          }\n        }\n\n        if (!list.loose) {\n          // If the previous item ended with a blank line, the list is loose\n          if (endsWithBlankLine) {\n            list.loose = true;\n          } else if (/\\n *\\n *$/.test(raw)) {\n            endsWithBlankLine = true;\n          }\n        }\n\n        // Check for task list items\n        if (this.options.gfm) {\n          istask = /^\\[[ xX]\\] /.exec(itemContents);\n          if (istask) {\n            ischecked = istask[0] !== '[ ] ';\n            itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n          }\n        }\n\n        list.items.push({\n          type: 'list_item',\n          raw,\n          task: !!istask,\n          checked: ischecked,\n          loose: false,\n          text: itemContents\n        });\n\n        list.raw += raw;\n      }\n\n      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n      list.items[list.items.length - 1].raw = raw.trimRight();\n      list.items[list.items.length - 1].text = itemContents.trimRight();\n      list.raw = list.raw.trimRight();\n\n      const l = list.items.length;\n\n      // Item child tokens handled here at end because we needed to have the final item to trim it first\n      for (i = 0; i < l; i++) {\n        this.lexer.state.top = false;\n        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\n        if (!list.loose) {\n          // Check if list should be loose\n          const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n\n          list.loose = hasMultipleLineBreaks;\n        }\n      }\n\n      // Set all items to loose if list is loose\n      if (list.loose) {\n        for (i = 0; i < l; i++) {\n          list.items[i].loose = true;\n        }\n      }\n\n      return list;\n    }\n  }\n\n  html(src) {\n    const cap = this.rules.block.html.exec(src);\n    if (cap) {\n      const token = {\n        type: 'html',\n        raw: cap[0],\n        pre: !this.options.sanitizer\n          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n        text: cap[0]\n      };\n      if (this.options.sanitize) {\n        const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);\n        token.type = 'paragraph';\n        token.text = text;\n        token.tokens = this.lexer.inline(text);\n      }\n      return token;\n    }\n  }\n\n  def(src) {\n    const cap = this.rules.block.def.exec(src);\n    if (cap) {\n      const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline._escapes, '$1') : '';\n      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, '$1') : cap[3];\n      return {\n        type: 'def',\n        tag,\n        raw: cap[0],\n        href,\n        title\n      };\n    }\n  }\n\n  table(src) {\n    const cap = this.rules.block.table.exec(src);\n    if (cap) {\n      const item = {\n        type: 'table',\n        header: splitCells(cap[1]).map(c => { return { text: c }; }),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : []\n      };\n\n      if (item.header.length === item.align.length) {\n        item.raw = cap[0];\n\n        let l = item.align.length;\n        let i, j, k, row;\n        for (i = 0; i < l; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        l = item.rows.length;\n        for (i = 0; i < l; i++) {\n          item.rows[i] = splitCells(item.rows[i], item.header.length).map(c => { return { text: c }; });\n        }\n\n        // parse child tokens inside headers and cells\n\n        // header child tokens\n        l = item.header.length;\n        for (j = 0; j < l; j++) {\n          item.header[j].tokens = this.lexer.inline(item.header[j].text);\n        }\n\n        // cell child tokens\n        l = item.rows.length;\n        for (j = 0; j < l; j++) {\n          row = item.rows[j];\n          for (k = 0; k < row.length; k++) {\n            row[k].tokens = this.lexer.inline(row[k].text);\n          }\n        }\n\n        return item;\n      }\n    }\n  }\n\n  lheading(src) {\n    const cap = this.rules.block.lheading.exec(src);\n    if (cap) {\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[2].charAt(0) === '=' ? 1 : 2,\n        text: cap[1],\n        tokens: this.lexer.inline(cap[1])\n      };\n    }\n  }\n\n  paragraph(src) {\n    const cap = this.rules.block.paragraph.exec(src);\n    if (cap) {\n      const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n        ? cap[1].slice(0, -1)\n        : cap[1];\n      return {\n        type: 'paragraph',\n        raw: cap[0],\n        text,\n        tokens: this.lexer.inline(text)\n      };\n    }\n  }\n\n  text(src) {\n    const cap = this.rules.block.text.exec(src);\n    if (cap) {\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        tokens: this.lexer.inline(cap[0])\n      };\n    }\n  }\n\n  escape(src) {\n    const cap = this.rules.inline.escape.exec(src);\n    if (cap) {\n      return {\n        type: 'escape',\n        raw: cap[0],\n        text: escape(cap[1])\n      };\n    }\n  }\n\n  tag(src) {\n    const cap = this.rules.inline.tag.exec(src);\n    if (cap) {\n      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n        this.lexer.state.inLink = true;\n      } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n        this.lexer.state.inLink = false;\n      }\n      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        this.lexer.state.inRawBlock = true;\n      } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        this.lexer.state.inRawBlock = false;\n      }\n\n      return {\n        type: this.options.sanitize\n          ? 'text'\n          : 'html',\n        raw: cap[0],\n        inLink: this.lexer.state.inLink,\n        inRawBlock: this.lexer.state.inRawBlock,\n        text: this.options.sanitize\n          ? (this.options.sanitizer\n            ? this.options.sanitizer(cap[0])\n            : escape(cap[0]))\n          : cap[0]\n      };\n    }\n  }\n\n  link(src) {\n    const cap = this.rules.inline.link.exec(src);\n    if (cap) {\n      const trimmedUrl = cap[2].trim();\n      if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n        // commonmark requires matching angle brackets\n        if (!(/>$/.test(trimmedUrl))) {\n          return;\n        }\n\n        // ending angle bracket cannot be escaped\n        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n          return;\n        }\n      } else {\n        // find closing parenthesis\n        const lastParenIndex = findClosingBracket(cap[2], '()');\n        if (lastParenIndex > -1) {\n          const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n          const linkLen = start + cap[1].length + lastParenIndex;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n      }\n      let href = cap[2];\n      let title = '';\n      if (this.options.pedantic) {\n        // split pedantic href and title\n        const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n        if (link) {\n          href = link[1];\n          title = link[3];\n        }\n      } else {\n        title = cap[3] ? cap[3].slice(1, -1) : '';\n      }\n\n      href = href.trim();\n      if (/^</.test(href)) {\n        if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n          // pedantic allows starting angle bracket without ending angle bracket\n          href = href.slice(1);\n        } else {\n          href = href.slice(1, -1);\n        }\n      }\n      return outputLink(cap, {\n        href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n        title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n      }, cap[0], this.lexer);\n    }\n  }\n\n  reflink(src, links) {\n    let cap;\n    if ((cap = this.rules.inline.reflink.exec(src))\n        || (cap = this.rules.inline.nolink.exec(src))) {\n      let link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = links[link.toLowerCase()];\n      if (!link) {\n        const text = cap[0].charAt(0);\n        return {\n          type: 'text',\n          raw: text,\n          text\n        };\n      }\n      return outputLink(cap, link, cap[0], this.lexer);\n    }\n  }\n\n  emStrong(src, maskedSrc, prevChar = '') {\n    let match = this.rules.inline.emStrong.lDelim.exec(src);\n    if (!match) return;\n\n    // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n    if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n\n    const nextChar = match[1] || match[2] || '';\n\n    if (!nextChar || (nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {\n      const lLength = match[0].length - 1;\n      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\n      const endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n      endReg.lastIndex = 0;\n\n      // Clip maskedSrc to same section of string as src (move to lexer?)\n      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\n        if (!rDelim) continue; // skip single * in __abc*abc__\n\n        rLength = rDelim.length;\n\n        if (match[3] || match[4]) { // found another Left Delim\n          delimTotal += rLength;\n          continue;\n        } else if (match[5] || match[6]) { // either Left or Right Delim\n          if (lLength % 3 && !((lLength + rLength) % 3)) {\n            midDelimTotal += rLength;\n            continue; // CommonMark Emphasis Rules 9-10\n          }\n        }\n\n        delimTotal -= rLength;\n\n        if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n\n        // Remove extra characters. *a*** -> *a*\n        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n\n        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);\n\n        // Create `em` if smallest delimiter has odd char count. *a***\n        if (Math.min(lLength, rLength) % 2) {\n          const text = raw.slice(1, -1);\n          return {\n            type: 'em',\n            raw,\n            text,\n            tokens: this.lexer.inlineTokens(text)\n          };\n        }\n\n        // Create 'strong' if smallest delimiter has even char count. **a***\n        const text = raw.slice(2, -2);\n        return {\n          type: 'strong',\n          raw,\n          text,\n          tokens: this.lexer.inlineTokens(text)\n        };\n      }\n    }\n  }\n\n  codespan(src) {\n    const cap = this.rules.inline.code.exec(src);\n    if (cap) {\n      let text = cap[2].replace(/\\n/g, ' ');\n      const hasNonSpaceChars = /[^ ]/.test(text);\n      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n        text = text.substring(1, text.length - 1);\n      }\n      text = escape(text, true);\n      return {\n        type: 'codespan',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n\n  br(src) {\n    const cap = this.rules.inline.br.exec(src);\n    if (cap) {\n      return {\n        type: 'br',\n        raw: cap[0]\n      };\n    }\n  }\n\n  del(src) {\n    const cap = this.rules.inline.del.exec(src);\n    if (cap) {\n      return {\n        type: 'del',\n        raw: cap[0],\n        text: cap[2],\n        tokens: this.lexer.inlineTokens(cap[2])\n      };\n    }\n  }\n\n  autolink(src, mangle) {\n    const cap = this.rules.inline.autolink.exec(src);\n    if (cap) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n        href = 'mailto:' + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text\n          }\n        ]\n      };\n    }\n  }\n\n  url(src, mangle) {\n    let cap;\n    if (cap = this.rules.inline.url.exec(src)) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n        href = 'mailto:' + text;\n      } else {\n        // do extended autolink path validation\n        let prevCapZero;\n        do {\n          prevCapZero = cap[0];\n          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n        } while (prevCapZero !== cap[0]);\n        text = escape(cap[0]);\n        if (cap[1] === 'www.') {\n          href = 'http://' + cap[0];\n        } else {\n          href = cap[0];\n        }\n      }\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text\n          }\n        ]\n      };\n    }\n  }\n\n  inlineText(src, smartypants) {\n    const cap = this.rules.inline.text.exec(src);\n    if (cap) {\n      let text;\n      if (this.lexer.state.inRawBlock) {\n        text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0];\n      } else {\n        text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n      }\n      return {\n        type: 'text',\n        raw: cap[0],\n        text\n      };\n    }\n  }\n}\n\n/**\n * Block-Level Grammar\n */\nconst block = {\n  newline: /^(?: *(?:\\n|$))+/,\n  code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n  fences: /^ {0,3}(`{3,}(?=[^`\\n]*\\n)|~{3,})([^\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n  hr: /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,\n  heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n  blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n  list: /^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/,\n  html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n    + ')',\n  def: /^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/,\n  table: noopTest,\n  lheading: /^((?:.|\\n(?!\\n))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  // regex template, placeholders will be replaced according to different paragraph\n  // interruption rules of commonmark and the original markdown spec:\n  _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,\n  text: /^[^\\n]+/\n};\n\nblock._label = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def)\n  .replace('label', block._label)\n  .replace('title', block._title)\n  .getRegex();\n\nblock.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nblock.listItemStart = edit(/^( *)(bull) */)\n  .replace('bull', block.bullet)\n  .getRegex();\n\nblock.list = edit(block.list)\n  .replace(/bull/g, block.bullet)\n  .replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))')\n  .replace('def', '\\\\n+(?=' + block.def.source + ')')\n  .getRegex();\n\nblock._tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'\n  + '|track|ul';\nblock._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nblock.html = edit(block.html, 'i')\n  .replace('comment', block._comment)\n  .replace('tag', block._tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nblock.paragraph = edit(block._paragraph)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('|table', '')\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.blockquote = edit(block.blockquote)\n  .replace('paragraph', block.paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = merge({}, block);\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = merge({}, block.normal, {\n  table: '^ *([^\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)(?:\\\\| *)?' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n});\n\nblock.gfm.table = edit(block.gfm.table)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', ' {4}[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.gfm.paragraph = edit(block._paragraph)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} ')\n  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('table', block.gfm.table) // interrupt paragraphs with table\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nblock.pedantic = merge({}, block.normal, {\n  html: edit(\n    '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n    + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n    .replace('comment', block._comment)\n    .replace(/tag/g, '(?!(?:'\n      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n      + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n    .getRegex(),\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n  heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n  fences: noopTest, // fences not supported\n  lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  paragraph: edit(block.normal._paragraph)\n    .replace('hr', block.hr)\n    .replace('heading', ' *#{1,6} *[^\\n]')\n    .replace('lheading', block.lheading)\n    .replace('blockquote', ' {0,3}>')\n    .replace('|fences', '')\n    .replace('|list', '')\n    .replace('|html', '')\n    .getRegex()\n});\n\n/**\n * Inline-Level Grammar\n */\nconst inline = {\n  escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n  autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n  url: noopTest,\n  tag: '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>', // CDATA section\n  link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n  reflink: /^!?\\[(label)\\]\\[(ref)\\]/,\n  nolink: /^!?\\[(ref)\\](?:\\[\\])?/,\n  reflinkSearch: 'reflink|nolink(?!\\\\()',\n  emStrong: {\n    lDelim: /^(?:\\*+(?:([punct_])|[^\\s*]))|^_+(?:([punct*])|([^\\s_]))/,\n    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a\n    rDelimAst: /^(?:[^_*\\\\]|\\\\.)*?\\_\\_(?:[^_*\\\\]|\\\\.)*?\\*(?:[^_*\\\\]|\\\\.)*?(?=\\_\\_)|(?:[^*\\\\]|\\\\.)+(?=[^*])|[punct_](\\*+)(?=[\\s]|$)|(?:[^punct*_\\s\\\\]|\\\\.)(\\*+)(?=[punct_\\s]|$)|[punct_\\s](\\*+)(?=[^punct*_\\s])|[\\s](\\*+)(?=[punct_])|[punct_](\\*+)(?=[punct_])|(?:[^punct*_\\s\\\\]|\\\\.)(\\*+)(?=[^punct*_\\s])/,\n    rDelimUnd: /^(?:[^_*\\\\]|\\\\.)*?\\*\\*(?:[^_*\\\\]|\\\\.)*?\\_(?:[^_*\\\\]|\\\\.)*?(?=\\*\\*)|(?:[^_\\\\]|\\\\.)+(?=[^_])|[punct*](\\_+)(?=[\\s]|$)|(?:[^punct*_\\s\\\\]|\\\\.)(\\_+)(?=[punct*\\s]|$)|[punct*\\s](\\_+)(?=[^punct*_\\s])|[\\s](\\_+)(?=[punct*])|[punct*](\\_+)(?=[punct*])/ // ^- Not allowed for _\n  },\n  code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n  br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n  del: noopTest,\n  text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n  punctuation: /^([\\spunctuation])/\n};\n\n// list of punctuation marks from CommonMark spec\n// without * and _ to handle the different emphasis markers * and _\ninline._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\ninline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();\n\n// sequences em should skip over [title](link), `code`, <html>\ninline.blockSkip = /\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>/g;\n// lookbehind is not available on Safari as of version 16\n// inline.escapedEmSt = /(?<=(?:^|[^\\\\)(?:\\\\[^])*)\\\\[*_]/g;\ninline.escapedEmSt = /(?:^|[^\\\\])(?:\\\\\\\\)*\\\\[*_]/g;\n\ninline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();\n\ninline.emStrong.lDelim = edit(inline.emStrong.lDelim)\n  .replace(/punct/g, inline._punctuation)\n  .getRegex();\n\ninline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'g')\n  .replace(/punct/g, inline._punctuation)\n  .getRegex();\n\ninline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'g')\n  .replace(/punct/g, inline._punctuation)\n  .getRegex();\n\ninline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink)\n  .replace('scheme', inline._scheme)\n  .replace('email', inline._email)\n  .getRegex();\n\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n\ninline.tag = edit(inline.tag)\n  .replace('comment', inline._comment)\n  .replace('attribute', inline._attribute)\n  .getRegex();\n\ninline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\ninline._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n\ninline.link = edit(inline.link)\n  .replace('label', inline._label)\n  .replace('href', inline._href)\n  .replace('title', inline._title)\n  .getRegex();\n\ninline.reflink = edit(inline.reflink)\n  .replace('label', inline._label)\n  .replace('ref', block._label)\n  .getRegex();\n\ninline.nolink = edit(inline.nolink)\n  .replace('ref', block._label)\n  .getRegex();\n\ninline.reflinkSearch = edit(inline.reflinkSearch, 'g')\n  .replace('reflink', inline.reflink)\n  .replace('nolink', inline.nolink)\n  .getRegex();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = merge({}, inline);\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = merge({}, inline.normal, {\n  strong: {\n    start: /^__|\\*\\*/,\n    middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n    endAst: /\\*\\*(?!\\*)/g,\n    endUnd: /__(?!_)/g\n  },\n  em: {\n    start: /^_|\\*/,\n    middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n    endAst: /\\*(?!\\*)/g,\n    endUnd: /_(?!_)/g\n  },\n  link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n    .replace('label', inline._label)\n    .getRegex(),\n  reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n    .replace('label', inline._label)\n    .getRegex()\n});\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = merge({}, inline.normal, {\n  escape: edit(inline.escape).replace('])', '~|])').getRegex(),\n  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n  url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n  _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n  del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n  text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n});\n\ninline.gfm.url = edit(inline.gfm.url, 'i')\n  .replace('email', inline.gfm._extended_email)\n  .getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = merge({}, inline.gfm, {\n  br: edit(inline.br).replace('{2,}', '*').getRegex(),\n  text: edit(inline.gfm.text)\n    .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n    .replace(/\\{2,\\}/g, '*')\n    .getRegex()\n});\n\n/**\n * smartypants text replacement\n * @param {string} text\n */\nfunction smartypants(text) {\n  return text\n    // em-dashes\n    .replace(/---/g, '\\u2014')\n    // en-dashes\n    .replace(/--/g, '\\u2013')\n    // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n    // closing singles & apostrophes\n    .replace(/'/g, '\\u2019')\n    // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n    // closing doubles\n    .replace(/\"/g, '\\u201d')\n    // ellipses\n    .replace(/\\.{3}/g, '\\u2026');\n}\n\n/**\n * mangle email addresses\n * @param {string} text\n */\nfunction mangle(text) {\n  let out = '',\n    i,\n    ch;\n\n  const l = text.length;\n  for (i = 0; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n}\n\n/**\n * Block Lexer\n */\nclass Lexer {\n  constructor(options) {\n    this.tokens = [];\n    this.tokens.links = Object.create(null);\n    this.options = options || defaults;\n    this.options.tokenizer = this.options.tokenizer || new Tokenizer();\n    this.tokenizer = this.options.tokenizer;\n    this.tokenizer.options = this.options;\n    this.tokenizer.lexer = this;\n    this.inlineQueue = [];\n    this.state = {\n      inLink: false,\n      inRawBlock: false,\n      top: true\n    };\n\n    const rules = {\n      block: block.normal,\n      inline: inline.normal\n    };\n\n    if (this.options.pedantic) {\n      rules.block = block.pedantic;\n      rules.inline = inline.pedantic;\n    } else if (this.options.gfm) {\n      rules.block = block.gfm;\n      if (this.options.breaks) {\n        rules.inline = inline.breaks;\n      } else {\n        rules.inline = inline.gfm;\n      }\n    }\n    this.tokenizer.rules = rules;\n  }\n\n  /**\n   * Expose Rules\n   */\n  static get rules() {\n    return {\n      block,\n      inline\n    };\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.lex(src);\n  }\n\n  /**\n   * Static Lex Inline Method\n   */\n  static lexInline(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.inlineTokens(src);\n  }\n\n  /**\n   * Preprocessing\n   */\n  lex(src) {\n    src = src\n      .replace(/\\r\\n|\\r/g, '\\n');\n\n    this.blockTokens(src, this.tokens);\n\n    let next;\n    while (next = this.inlineQueue.shift()) {\n      this.inlineTokens(next.src, next.tokens);\n    }\n\n    return this.tokens;\n  }\n\n  /**\n   * Lexing\n   */\n  blockTokens(src, tokens = []) {\n    if (this.options.pedantic) {\n      src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n    } else {\n      src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n        return leading + '    '.repeat(tabs.length);\n      });\n    }\n\n    let token, lastToken, cutSrc, lastParagraphClipped;\n\n    while (src) {\n      if (this.options.extensions\n        && this.options.extensions.block\n        && this.options.extensions.block.some((extTokenizer) => {\n          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n          return false;\n        })) {\n        continue;\n      }\n\n      // newline\n      if (token = this.tokenizer.space(src)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.length === 1 && tokens.length > 0) {\n          // if there's a single \\n as a spacer, it's terminating the last line,\n          // so move it there so that we don't get unecessary paragraph tags\n          tokens[tokens.length - 1].raw += '\\n';\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.code(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        // An indented code block cannot interrupt a paragraph.\n        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // fences\n      if (token = this.tokenizer.fences(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // heading\n      if (token = this.tokenizer.heading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // hr\n      if (token = this.tokenizer.hr(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // blockquote\n      if (token = this.tokenizer.blockquote(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // list\n      if (token = this.tokenizer.list(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // html\n      if (token = this.tokenizer.html(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // def\n      if (token = this.tokenizer.def(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.raw;\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else if (!this.tokens.links[token.tag]) {\n          this.tokens.links[token.tag] = {\n            href: token.href,\n            title: token.title\n          };\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (token = this.tokenizer.table(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // lheading\n      if (token = this.tokenizer.lheading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // top-level paragraph\n      // prevent paragraph consuming extensions by clipping 'src' to extension start\n      cutSrc = src;\n      if (this.options.extensions && this.options.extensions.startBlock) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startBlock.forEach(function(getStartIndex) {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) { startIndex = Math.min(startIndex, tempStart); }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n        lastToken = tokens[tokens.length - 1];\n        if (lastParagraphClipped && lastToken.type === 'paragraph') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        lastParagraphClipped = (cutSrc.length !== src.length);\n        src = src.substring(token.raw.length);\n        continue;\n      }\n\n      // text\n      if (token = this.tokenizer.text(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && lastToken.type === 'text') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    this.state.top = true;\n    return tokens;\n  }\n\n  inline(src, tokens = []) {\n    this.inlineQueue.push({ src, tokens });\n    return tokens;\n  }\n\n  /**\n   * Lexing/Compiling\n   */\n  inlineTokens(src, tokens = []) {\n    let token, lastToken, cutSrc;\n\n    // String with links masked to avoid interference with em and strong\n    let maskedSrc = src;\n    let match;\n    let keepPrevChar, prevChar;\n\n    // Mask out reflinks\n    if (this.tokens.links) {\n      const links = Object.keys(this.tokens.links);\n      if (links.length > 0) {\n        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n          }\n        }\n      }\n    }\n    // Mask out other blocks\n    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n    }\n\n    // Mask out escaped em & strong delimiters\n    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);\n      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;\n    }\n\n    while (src) {\n      if (!keepPrevChar) {\n        prevChar = '';\n      }\n      keepPrevChar = false;\n\n      // extensions\n      if (this.options.extensions\n        && this.options.extensions.inline\n        && this.options.extensions.inline.some((extTokenizer) => {\n          if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n          return false;\n        })) {\n        continue;\n      }\n\n      // escape\n      if (token = this.tokenizer.escape(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // tag\n      if (token = this.tokenizer.tag(src)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // link\n      if (token = this.tokenizer.link(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // reflink, nolink\n      if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n        src = src.substring(token.raw.length);\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // em & strong\n      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.codespan(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // br\n      if (token = this.tokenizer.br(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // del (gfm)\n      if (token = this.tokenizer.del(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // autolink\n      if (token = this.tokenizer.autolink(src, mangle)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // url (gfm)\n      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      // prevent inlineText consuming extensions by clipping 'src' to extension start\n      cutSrc = src;\n      if (this.options.extensions && this.options.extensions.startInline) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startInline.forEach(function(getStartIndex) {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) { startIndex = Math.min(startIndex, tempStart); }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n          prevChar = token.raw.slice(-1);\n        }\n        keepPrevChar = true;\n        lastToken = tokens[tokens.length - 1];\n        if (lastToken && lastToken.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    return tokens;\n  }\n}\n\n/**\n * Renderer\n */\nclass Renderer {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  code(code, infostring, escaped) {\n    const lang = (infostring || '').match(/\\S*/)[0];\n    if (this.options.highlight) {\n      const out = this.options.highlight(code, lang);\n      if (out != null && out !== code) {\n        escaped = true;\n        code = out;\n      }\n    }\n\n    code = code.replace(/\\n$/, '') + '\\n';\n\n    if (!lang) {\n      return '<pre><code>'\n        + (escaped ? code : escape(code, true))\n        + '</code></pre>\\n';\n    }\n\n    return '<pre><code class=\"'\n      + this.options.langPrefix\n      + escape(lang)\n      + '\">'\n      + (escaped ? code : escape(code, true))\n      + '</code></pre>\\n';\n  }\n\n  /**\n   * @param {string} quote\n   */\n  blockquote(quote) {\n    return `<blockquote>\\n${quote}</blockquote>\\n`;\n  }\n\n  html(html) {\n    return html;\n  }\n\n  /**\n   * @param {string} text\n   * @param {string} level\n   * @param {string} raw\n   * @param {any} slugger\n   */\n  heading(text, level, raw, slugger) {\n    if (this.options.headerIds) {\n      const id = this.options.headerPrefix + slugger.slug(raw);\n      return `<h${level} id=\"${id}\">${text}</h${level}>\\n`;\n    }\n\n    // ignore IDs\n    return `<h${level}>${text}</h${level}>\\n`;\n  }\n\n  hr() {\n    return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n  }\n\n  list(body, ordered, start) {\n    const type = ordered ? 'ol' : 'ul',\n      startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n    return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n  }\n\n  /**\n   * @param {string} text\n   */\n  listitem(text) {\n    return `<li>${text}</li>\\n`;\n  }\n\n  checkbox(checked) {\n    return '<input '\n      + (checked ? 'checked=\"\" ' : '')\n      + 'disabled=\"\" type=\"checkbox\"'\n      + (this.options.xhtml ? ' /' : '')\n      + '> ';\n  }\n\n  /**\n   * @param {string} text\n   */\n  paragraph(text) {\n    return `<p>${text}</p>\\n`;\n  }\n\n  /**\n   * @param {string} header\n   * @param {string} body\n   */\n  table(header, body) {\n    if (body) body = `<tbody>${body}</tbody>`;\n\n    return '<table>\\n'\n      + '<thead>\\n'\n      + header\n      + '</thead>\\n'\n      + body\n      + '</table>\\n';\n  }\n\n  /**\n   * @param {string} content\n   */\n  tablerow(content) {\n    return `<tr>\\n${content}</tr>\\n`;\n  }\n\n  tablecell(content, flags) {\n    const type = flags.header ? 'th' : 'td';\n    const tag = flags.align\n      ? `<${type} align=\"${flags.align}\">`\n      : `<${type}>`;\n    return tag + content + `</${type}>\\n`;\n  }\n\n  /**\n   * span level renderer\n   * @param {string} text\n   */\n  strong(text) {\n    return `<strong>${text}</strong>`;\n  }\n\n  /**\n   * @param {string} text\n   */\n  em(text) {\n    return `<em>${text}</em>`;\n  }\n\n  /**\n   * @param {string} text\n   */\n  codespan(text) {\n    return `<code>${text}</code>`;\n  }\n\n  br() {\n    return this.options.xhtml ? '<br/>' : '<br>';\n  }\n\n  /**\n   * @param {string} text\n   */\n  del(text) {\n    return `<del>${text}</del>`;\n  }\n\n  /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */\n  link(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n    let out = '<a href=\"' + href + '\"';\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n    out += '>' + text + '</a>';\n    return out;\n  }\n\n  /**\n   * @param {string} href\n   * @param {string} title\n   * @param {string} text\n   */\n  image(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n\n    let out = `<img src=\"${href}\" alt=\"${text}\"`;\n    if (title) {\n      out += ` title=\"${title}\"`;\n    }\n    out += this.options.xhtml ? '/>' : '>';\n    return out;\n  }\n\n  text(text) {\n    return text;\n  }\n}\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nclass TextRenderer {\n  // no need for block level renderers\n  strong(text) {\n    return text;\n  }\n\n  em(text) {\n    return text;\n  }\n\n  codespan(text) {\n    return text;\n  }\n\n  del(text) {\n    return text;\n  }\n\n  html(text) {\n    return text;\n  }\n\n  text(text) {\n    return text;\n  }\n\n  link(href, title, text) {\n    return '' + text;\n  }\n\n  image(href, title, text) {\n    return '' + text;\n  }\n\n  br() {\n    return '';\n  }\n}\n\n/**\n * Slugger generates header id\n */\nclass Slugger {\n  constructor() {\n    this.seen = {};\n  }\n\n  /**\n   * @param {string} value\n   */\n  serialize(value) {\n    return value\n      .toLowerCase()\n      .trim()\n      // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '')\n      // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '')\n      .replace(/\\s/g, '-');\n  }\n\n  /**\n   * Finds the next safe (unique) slug to use\n   * @param {string} originalSlug\n   * @param {boolean} isDryRun\n   */\n  getNextSafeSlug(originalSlug, isDryRun) {\n    let slug = originalSlug;\n    let occurenceAccumulator = 0;\n    if (this.seen.hasOwnProperty(slug)) {\n      occurenceAccumulator = this.seen[originalSlug];\n      do {\n        occurenceAccumulator++;\n        slug = originalSlug + '-' + occurenceAccumulator;\n      } while (this.seen.hasOwnProperty(slug));\n    }\n    if (!isDryRun) {\n      this.seen[originalSlug] = occurenceAccumulator;\n      this.seen[slug] = 0;\n    }\n    return slug;\n  }\n\n  /**\n   * Convert string to unique id\n   * @param {object} [options]\n   * @param {boolean} [options.dryrun] Generates the next unique slug without\n   * updating the internal accumulator.\n   */\n  slug(value, options = {}) {\n    const slug = this.serialize(value);\n    return this.getNextSafeSlug(slug, options.dryrun);\n  }\n}\n\n/**\n * Parsing & Compiling\n */\nclass Parser {\n  constructor(options) {\n    this.options = options || defaults;\n    this.options.renderer = this.options.renderer || new Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.textRenderer = new TextRenderer();\n    this.slugger = new Slugger();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parse(tokens);\n  }\n\n  /**\n   * Static Parse Inline Method\n   */\n  static parseInline(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parseInline(tokens);\n  }\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens, top = true) {\n    let out = '',\n      i,\n      j,\n      k,\n      l2,\n      l3,\n      row,\n      cell,\n      header,\n      body,\n      token,\n      ordered,\n      start,\n      loose,\n      itemBody,\n      item,\n      checked,\n      task,\n      checkbox,\n      ret;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);\n        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      switch (token.type) {\n        case 'space': {\n          continue;\n        }\n        case 'hr': {\n          out += this.renderer.hr();\n          continue;\n        }\n        case 'heading': {\n          out += this.renderer.heading(\n            this.parseInline(token.tokens),\n            token.depth,\n            unescape(this.parseInline(token.tokens, this.textRenderer)),\n            this.slugger);\n          continue;\n        }\n        case 'code': {\n          out += this.renderer.code(token.text,\n            token.lang,\n            token.escaped);\n          continue;\n        }\n        case 'table': {\n          header = '';\n\n          // header\n          cell = '';\n          l2 = token.header.length;\n          for (j = 0; j < l2; j++) {\n            cell += this.renderer.tablecell(\n              this.parseInline(token.header[j].tokens),\n              { header: true, align: token.align[j] }\n            );\n          }\n          header += this.renderer.tablerow(cell);\n\n          body = '';\n          l2 = token.rows.length;\n          for (j = 0; j < l2; j++) {\n            row = token.rows[j];\n\n            cell = '';\n            l3 = row.length;\n            for (k = 0; k < l3; k++) {\n              cell += this.renderer.tablecell(\n                this.parseInline(row[k].tokens),\n                { header: false, align: token.align[k] }\n              );\n            }\n\n            body += this.renderer.tablerow(cell);\n          }\n          out += this.renderer.table(header, body);\n          continue;\n        }\n        case 'blockquote': {\n          body = this.parse(token.tokens);\n          out += this.renderer.blockquote(body);\n          continue;\n        }\n        case 'list': {\n          ordered = token.ordered;\n          start = token.start;\n          loose = token.loose;\n          l2 = token.items.length;\n\n          body = '';\n          for (j = 0; j < l2; j++) {\n            item = token.items[j];\n            checked = item.checked;\n            task = item.task;\n\n            itemBody = '';\n            if (item.task) {\n              checkbox = this.renderer.checkbox(checked);\n              if (loose) {\n                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                  item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                    item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                  }\n                } else {\n                  item.tokens.unshift({\n                    type: 'text',\n                    text: checkbox\n                  });\n                }\n              } else {\n                itemBody += checkbox;\n              }\n            }\n\n            itemBody += this.parse(item.tokens, loose);\n            body += this.renderer.listitem(itemBody, task, checked);\n          }\n\n          out += this.renderer.list(body, ordered, start);\n          continue;\n        }\n        case 'html': {\n          // TODO parse inline content if parameter markdown=1\n          out += this.renderer.html(token.text);\n          continue;\n        }\n        case 'paragraph': {\n          out += this.renderer.paragraph(this.parseInline(token.tokens));\n          continue;\n        }\n        case 'text': {\n          body = token.tokens ? this.parseInline(token.tokens) : token.text;\n          while (i + 1 < l && tokens[i + 1].type === 'text') {\n            token = tokens[++i];\n            body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n          }\n          out += top ? this.renderer.paragraph(body) : body;\n          continue;\n        }\n\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parse Inline Tokens\n   */\n  parseInline(tokens, renderer) {\n    renderer = renderer || this.renderer;\n    let out = '',\n      i,\n      token,\n      ret;\n\n    const l = tokens.length;\n    for (i = 0; i < l; i++) {\n      token = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);\n        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      switch (token.type) {\n        case 'escape': {\n          out += renderer.text(token.text);\n          break;\n        }\n        case 'html': {\n          out += renderer.html(token.text);\n          break;\n        }\n        case 'link': {\n          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'image': {\n          out += renderer.image(token.href, token.title, token.text);\n          break;\n        }\n        case 'strong': {\n          out += renderer.strong(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'em': {\n          out += renderer.em(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'codespan': {\n          out += renderer.codespan(token.text);\n          break;\n        }\n        case 'br': {\n          out += renderer.br();\n          break;\n        }\n        case 'del': {\n          out += renderer.del(this.parseInline(token.tokens, renderer));\n          break;\n        }\n        case 'text': {\n          out += renderer.text(token.text);\n          break;\n        }\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n    return out;\n  }\n}\n\n/**\n * Marked\n */\nfunction marked(src, opt, callback) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked(): input parameter is undefined or null');\n  }\n  if (typeof src !== 'string') {\n    throw new Error('marked(): input parameter is of type '\n      + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  if (typeof opt === 'function') {\n    callback = opt;\n    opt = null;\n  }\n\n  opt = merge({}, marked.defaults, opt || {});\n  checkSanitizeDeprecation(opt);\n\n  if (callback) {\n    const highlight = opt.highlight;\n    let tokens;\n\n    try {\n      tokens = Lexer.lex(src, opt);\n    } catch (e) {\n      return callback(e);\n    }\n\n    const done = function(err) {\n      let out;\n\n      if (!err) {\n        try {\n          if (opt.walkTokens) {\n            marked.walkTokens(tokens, opt.walkTokens);\n          }\n          out = Parser.parse(tokens, opt);\n        } catch (e) {\n          err = e;\n        }\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!tokens.length) return done();\n\n    let pending = 0;\n    marked.walkTokens(tokens, function(token) {\n      if (token.type === 'code') {\n        pending++;\n        setTimeout(() => {\n          highlight(token.text, token.lang, function(err, code) {\n            if (err) {\n              return done(err);\n            }\n            if (code != null && code !== token.text) {\n              token.text = code;\n              token.escaped = true;\n            }\n\n            pending--;\n            if (pending === 0) {\n              done();\n            }\n          });\n        }, 0);\n      }\n    });\n\n    if (pending === 0) {\n      done();\n    }\n\n    return;\n  }\n\n  function onError(e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n    if (opt.silent) {\n      return '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n\n  try {\n    const tokens = Lexer.lex(src, opt);\n    if (opt.walkTokens) {\n      if (opt.async) {\n        return Promise.all(marked.walkTokens(tokens, opt.walkTokens))\n          .then(() => {\n            return Parser.parse(tokens, opt);\n          })\n          .catch(onError);\n      }\n      marked.walkTokens(tokens, opt.walkTokens);\n    }\n    return Parser.parse(tokens, opt);\n  } catch (e) {\n    onError(e);\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\nmarked.getDefaults = getDefaults;\n\nmarked.defaults = defaults;\n\n/**\n * Use Extension\n */\n\nmarked.use = function(...args) {\n  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };\n\n  args.forEach((pack) => {\n    // copy options to new object\n    const opts = merge({}, pack);\n\n    // set async to true if it was set to true before\n    opts.async = marked.defaults.async || opts.async;\n\n    // ==-- Parse \"addon\" extensions --== //\n    if (pack.extensions) {\n      pack.extensions.forEach((ext) => {\n        if (!ext.name) {\n          throw new Error('extension name required');\n        }\n        if (ext.renderer) { // Renderer extensions\n          const prevRenderer = extensions.renderers[ext.name];\n          if (prevRenderer) {\n            // Replace extension with func to run new extension but fall back if false\n            extensions.renderers[ext.name] = function(...args) {\n              let ret = ext.renderer.apply(this, args);\n              if (ret === false) {\n                ret = prevRenderer.apply(this, args);\n              }\n              return ret;\n            };\n          } else {\n            extensions.renderers[ext.name] = ext.renderer;\n          }\n        }\n        if (ext.tokenizer) { // Tokenizer Extensions\n          if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n            throw new Error(\"extension level must be 'block' or 'inline'\");\n          }\n          if (extensions[ext.level]) {\n            extensions[ext.level].unshift(ext.tokenizer);\n          } else {\n            extensions[ext.level] = [ext.tokenizer];\n          }\n          if (ext.start) { // Function to check for start of token\n            if (ext.level === 'block') {\n              if (extensions.startBlock) {\n                extensions.startBlock.push(ext.start);\n              } else {\n                extensions.startBlock = [ext.start];\n              }\n            } else if (ext.level === 'inline') {\n              if (extensions.startInline) {\n                extensions.startInline.push(ext.start);\n              } else {\n                extensions.startInline = [ext.start];\n              }\n            }\n          }\n        }\n        if (ext.childTokens) { // Child tokens to be visited by walkTokens\n          extensions.childTokens[ext.name] = ext.childTokens;\n        }\n      });\n      opts.extensions = extensions;\n    }\n\n    // ==-- Parse \"overwrite\" extensions --== //\n    if (pack.renderer) {\n      const renderer = marked.defaults.renderer || new Renderer();\n      for (const prop in pack.renderer) {\n        const prevRenderer = renderer[prop];\n        // Replace renderer with func to run extension, but fall back if false\n        renderer[prop] = (...args) => {\n          let ret = pack.renderer[prop].apply(renderer, args);\n          if (ret === false) {\n            ret = prevRenderer.apply(renderer, args);\n          }\n          return ret;\n        };\n      }\n      opts.renderer = renderer;\n    }\n    if (pack.tokenizer) {\n      const tokenizer = marked.defaults.tokenizer || new Tokenizer();\n      for (const prop in pack.tokenizer) {\n        const prevTokenizer = tokenizer[prop];\n        // Replace tokenizer with func to run extension, but fall back if false\n        tokenizer[prop] = (...args) => {\n          let ret = pack.tokenizer[prop].apply(tokenizer, args);\n          if (ret === false) {\n            ret = prevTokenizer.apply(tokenizer, args);\n          }\n          return ret;\n        };\n      }\n      opts.tokenizer = tokenizer;\n    }\n\n    // ==-- Parse WalkTokens extensions --== //\n    if (pack.walkTokens) {\n      const walkTokens = marked.defaults.walkTokens;\n      opts.walkTokens = function(token) {\n        let values = [];\n        values.push(pack.walkTokens.call(this, token));\n        if (walkTokens) {\n          values = values.concat(walkTokens.call(this, token));\n        }\n        return values;\n      };\n    }\n\n    marked.setOptions(opts);\n  });\n};\n\n/**\n * Run callback for every token\n */\n\nmarked.walkTokens = function(tokens, callback) {\n  let values = [];\n  for (const token of tokens) {\n    values = values.concat(callback.call(marked, token));\n    switch (token.type) {\n      case 'table': {\n        for (const cell of token.header) {\n          values = values.concat(marked.walkTokens(cell.tokens, callback));\n        }\n        for (const row of token.rows) {\n          for (const cell of row) {\n            values = values.concat(marked.walkTokens(cell.tokens, callback));\n          }\n        }\n        break;\n      }\n      case 'list': {\n        values = values.concat(marked.walkTokens(token.items, callback));\n        break;\n      }\n      default: {\n        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) { // Walk any extensions\n          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {\n            values = values.concat(marked.walkTokens(token[childTokens], callback));\n          });\n        } else if (token.tokens) {\n          values = values.concat(marked.walkTokens(token.tokens, callback));\n        }\n      }\n    }\n  }\n  return values;\n};\n\n/**\n * Parse Inline\n * @param {string} src\n */\nmarked.parseInline = function(src, opt) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked.parseInline(): input parameter is undefined or null');\n  }\n  if (typeof src !== 'string') {\n    throw new Error('marked.parseInline(): input parameter is of type '\n      + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  opt = merge({}, marked.defaults, opt || {});\n  checkSanitizeDeprecation(opt);\n\n  try {\n    const tokens = Lexer.lexInline(src, opt);\n    if (opt.walkTokens) {\n      marked.walkTokens(tokens, opt.walkTokens);\n    }\n    return Parser.parseInline(tokens, opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n    if (opt.silent) {\n      return '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n};\n\n/**\n * Expose\n */\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\nmarked.Tokenizer = Tokenizer;\nmarked.Slugger = Slugger;\nmarked.parse = marked;\n\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = Parser.parse;\nconst lexer = Lexer.lex;\n\n\n\n\n//# sourceURL=webpack://study/./node_modules/marked/lib/marked.esm.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/scripts/index.ts");
/******/ 	
/******/ })()
;